/* global croquet_build_process */

import stableStringify from "fast-json-stable-stringify";
import Base64 from "crypto-js/enc-base64";
import Utf8 from "crypto-js/enc-utf8";
import PBKDF2 from "crypto-js/pbkdf2";
import AES from "crypto-js/aes";
import WordArray from "crypto-js/lib-typedarrays";
import HmacSHA256 from "crypto-js/hmac-sha256";

import pako from "pako"; // gzip-aware compressor

// the rollup config will replace the lines below with imports in the case of a Node.js build
// _ENSURE_WEBSOCKET_
// _ENSURE_FETCH_

import { Stats } from "./_STATS_MODULE_"; // eslint-disable-line import/no-unresolved
import urlOptions from "./_URLOPTIONS_MODULE_"; // eslint-disable-line import/no-unresolved
import { App, displayStatus, displayAppError } from "./_HTML_MODULE_"; // eslint-disable-line import/no-unresolved
import { hashNameAndOptions, hashSessionAndCode, hashString, cryptoJsWordArrayToUint8Array } from "./hashing";
import { inViewRealm } from "./realms";
import { viewDomain } from "./domain";
import VirtualMachine, { Message, inSequence } from "./vm";
/* eslint-disable-next-line import/order,import/no-unresolved */
import UploadWorkerFactory from "web-worker:./upload";      // generated by rollup

/** @typedef { import("./model").default } Model */
/** @typedef { {} } Session */

// when reflector has a new feature, we increment this value
// only newer clients get to use it
const VERSION = 1;

const CROQUET_VERSION = croquet_build_process.env.CROQUET_VERSION || "<unknown>";
const NODE = croquet_build_process.env.CROQUET_PLATFORM === "node";

// Node and codepen cannot deal with styled console output
if (NODE || window.location.hostname.match(/co?de?pe?n\.io/)) console.log("Croquet " + CROQUET_VERSION);
else console.log("%cCroquet%c %c" + CROQUET_VERSION, "color:#F0493E", "color:inherit", `color:${CROQUET_VERSION.includes('+') ? "#909" : "inherit"}`);

// use dev reflectors for pre-release SDKs, unless dev=false given
// (only needed for periods when code changes below require dev reflectors,
// comment out once deployed to production reflectors)
// if (!("dev" in urlOptions) && (CROQUET_VERSION === "<unknown>" || CROQUET_VERSION.includes('-'))) urlOptions.dev = true;

// *croquet.io/reflector/v1 is used as reflector for pages served from *croquet.io
// (specifically, pi.croquet.io must use its own reflector)
// everything else uses croquet.io/reflector/v1
// ...unless overridden by a CROQUET_REFLECTOR setting in the .env
// ...unless overridden by a "dev" url option, which selects the dev dispatcher and reflector
// ...unless overridden by a "reflector=<url>" url option, which sets the specified url

const appOnCroquetIo = !NODE && !!window.location.hostname.match(/^(.*\.)?croquet\.io$/i);
const appOnCroquetIoDev = appOnCroquetIo && window.location.pathname.startsWith("/dev/");
const appOnCroquetDev = !NODE && !!window.location.hostname.match(/^(.*\.)?croquet\.dev$/i);

const PUBLIC_REFLECTOR_HOST = appOnCroquetIo ? window.location.host : "croquet.io";
const DEFAULT_REFLECTOR = `wss://${PUBLIC_REFLECTOR_HOST}/reflector/v${VERSION}`;
const CLOUDFLARE_REFLECTOR = "wss://croquet.network/reflector/";
const DEV_CLOUDFLARE_REFLECTOR = "wss://croquet.network/reflector/dev/";

const OLD_UPLOAD_SERVER = "https://croquet.io/files/v1";    // for uploads without apiKey (unused)
const OLD_DOWNLOAD_SERVER = "https://files.croquet.io";     // downloads from old upload server (rewritten from old upload url)
const DEFAULT_SIGN_SERVER = "https://api.croquet.io/sign";  // get signed url for uploads with apiKey

const {SIGN_SERVER, REFLECTOR} = getBackendUrls();

function getBackendUrls() {
    // First check if the "backend" query param was set
    const backend = urlOptions.backend;

    if (backend) {
        return {
            SIGN_SERVER: `https://api.${backend}.croquet.dev/sign`,
            REFLECTOR: `wss://api.${backend}.croquet.dev/reflector/v${VERSION}`
        };
    }

    // below written so it works on NODE where we can't access window.location

    // if the backend query param was not set, we go off of the hostname
    // For dev projects (<PROJECT>.croquet.dev) we can grab the project off of the url
    if (appOnCroquetDev) {
        const hostname = window.location.hostname;
        const project = hostname.slice(0, -12); // '.croquet.dev'.length === 12
        return {
            SIGN_SERVER: `https://api.${project}.croquet.dev/sign`,
            REFLECTOR: `wss://api.${project}.croquet.dev/reflector/v${VERSION}`
        };
    }

    // old-style croquet.io/dev/ deploys use keys from prod firebase
    if (appOnCroquetIoDev || urlOptions.dev) {
        return {
            SIGN_SERVER: "https://api.croquet.io/dev/sign",
            REFLECTOR: "wss://croquet.io/reflector-dev/dev",
        };
    }

    // Otherwise we assume prod and use the default reflector/sign urls.
    return {
        SIGN_SERVER: DEFAULT_SIGN_SERVER,
        REFLECTOR: DEFAULT_REFLECTOR
    };
}

export const OLD_DATA_SERVER = OLD_DOWNLOAD_SERVER;

let DEBUG = null;

function initDEBUG() {
    // to capture whatever was passed to th latest Session.join({debug:...})
    // call we simply redo this every time establishSession() is called
    // TODO: turn this into a reasonable API
    // enable some opts by default via dev flag or being on localhost-equivalent
    const devOrLocal = urlOptions.dev || (urlOptions.dev !== false && "localhost");
    const devOrCroquetIoDev = urlOptions.dev || (urlOptions.dev !== false && (appOnCroquetIoDev || appOnCroquetDev));
    DEBUG = {
        messages: urlOptions.has("debug", "messages", false),               // received messages
        sends: urlOptions.has("debug", "sends", false),                     // sent messages
        ticks: urlOptions.has("debug", "ticks", false),                     // received ticks
        pong: urlOptions.has("debug", "pong", false),                       // received PONGs
        snapshot: urlOptions.has("debug", "snapshot", false),               // snapshotting, uploading etc
        session: urlOptions.has("debug", "session", false),                 // session logging
        initsnapshot: urlOptions.has("debug", "initsnapshot", devOrLocal),  // check snapshotting after initFn
        reflector: urlOptions.has("debug", "reflector", devOrCroquetIoDev), // use dev reflector
    };
}

const NOCHEAT = urlOptions.nocheat;

// schedule a snapshot after this many ms of CPU time have been used for simulation
const SNAPSHOT_EVERY = 5000;
// after reflecting one handlePollForSnapshot event, reflector will wait this many ms before allowing another
const SNAPSHOT_POLL_DEBOUNCE = 5000;

// add this many ms for each external message scheduled
const EXTERNAL_MESSAGE_CPU_PENALTY = 5;
const JOIN_FAILED_DELAY = 5000; // time after which we conclude that our sending of JOIN failed

// lag threshold in ms to publish "synced(true|false)" event (to start/stop rendering)
const SYNCED_MIN = 200;        // synced if tick arrives within this many ms ...
const SYNCED_MIN_FACTOR = 0.1; // ... or msPerTick times this (e.g. 30s/tick => 3s)
const SYNCED_MAX = 2000;       // unsynced if tick missing for this many ms ...
const SYNCED_MAX_FACTOR = 0.2; // ... or msPerTick times this (e.g. 30s/tick => 6s)
const SYNCED_ANNOUNCE_DELAY = 200; // ms to delay setting synced, mainly to accommodate immediate post-SYNC messages (notably "users") from reflector

// maximum amount of time in milliseconds the model gets to spend running its simulation
const MAX_SIMULATION_MS = 200;
// time spent simulating the last few frames
const simLoad = [0];
// number of frames to spread load
const LOAD_BALANCE_FRAMES = 4;
// number of steps to record for checking animation
const ANIMATION_CHECK_FRAMES = 4;
// don't assume animation has started until average inter-frame gap over ANIMATION_CHECK_FRAMES is less than this.  most browsers will be 33 or less, but there could be some slower-running systems out there (especially if app is stepping manually).
const ANIMATION_REASONABLE_FRAME_GAP = 100;
// assume animation has stopped if more than this delay in ms since end of most recent step
const ANIMATION_EXCESSIVE_FRAME_GAP = ANIMATION_REASONABLE_FRAME_GAP * 2;
// maximum recommended payload size (once string-encoded)
const PAYLOAD_LIMIT_RECOMMENDED = 4 * 1024;
// maximum allowed payload size
const PAYLOAD_LIMIT_MAX = 16 * 1024;

// for loading snapshots from before we required passwords
let DEPRECATED_DEFAULT_KEY; // initialized only when needed, for speed

function randomString() { return Math.floor(Math.random() * 36**10).toString(36); }

// start upload worker (upload.js)
const UploadWorker = new UploadWorkerFactory();
// const url = new URL("./upload.mjs", import.meta.url);
UploadWorker.onerror = e => console.error(`UploadWorker error: ${e.message}`);
let UploadJobs = 0;

const Controllers = new Set();

export function sessionProps(sessionId) {
    for (const controller of Controllers) {
        if (controller.id === sessionId) {
            const { appId, persistentId } = controller.sessionSpec;
            return {
                appId, persistentId,
                uploadEncrypted: opts => controller.uploadEncrypted(opts),
                downloadEncrypted: opts => controller.downloadEncrypted(opts),
            };
        }
    }
    return {};
}

export function sessionController(sessionId) {
    for (const controller of Controllers) {
        if (controller.id === sessionId) return controller;
    }
    return null;
}

export default class Controller {

    constructor() {
        initDEBUG();
        this.reset();
    }

    reset() {
        if (globalThis.CROQUETVM === this.vm) delete globalThis.CROQUETVM;
        /** @type {VirtualMachine} */
        this.vm = null;
        /** @type {Session} the session object as returned from Session.join, set in session.js. Not to be used here but only so that View.session can find it. Needs redesign. */
        this.session = null;
        /**  @type {Connection} our websocket connection for talking to the reflector */
        this.connection = this.connection || new Connection(this);
        /** the messages received from reflector */
        this.networkQueue = [];
        /** the time stamp of last message received from reflector, or internal tick */
        this.reflectorTime = 0;
        /** ms between expected ticks */
        this.msPerTick = this.msPerTick || 0;
        /** multiply reflector ticks if > 1 (a.k.a. "cheat beats") */
        this.tickMultiplier = this.tickMultiplier || 1;
        /** the local time at which we received the last time stamp, minus that time stamp */
        this.extrapolatedTimeBase = Date.now();
        /** key generated from password, shared by all clients in session */
        this.key = this.key || null;
        /** encrypted message used to verify all clients actually use the same key */
        this.tove = this.tove || null;
        /** @type {String} the client id (different in each replica, but stays the same on reconnect) */
        this.viewId = this.viewId || randomString(); // todo: have reflector assign unique ids
        /** @type {String} stateless reflectors always start new session, this is the only way to notice that */
        this.timeline = "";
        // just to be safe ...
        if (this.rejoinTimeout) clearTimeout(this.rejoinTimeout);
        /** timeout rejoin if rejoinLimit has been requested */
        this.rejoinTimeout = 0;
        /** @type {Function[]} buffered sends to reflector while reconnecting */
        this.sendBuffer = [];
        /** the number of concurrent users in our vm (excluding spectators) */
        this.users = 0;
        /** the number of concurrent users in our vm (including spectators) */
        this.usersTotal = 0;
        /** CPU time spent simulating since last snapshot */
        this.cpuTime = 0;
        /** CPU time spent at the point when we realised a snapshot is needed */
        this.triggeringCpuTime = null;
        /** @type {Boolean} backlog was below SYNCED_MIN */
        this.synced = null; // null indicates never synced before
        /** last measured latency in ms */
        this.latency = 0;
        // only collect latency history if asked for
        if (this.latencyHistory) {
            /** @type {Array<Number>} */
            this.latencyHistory = [];
        }
        // make sure we have no residual "multiply" ticks
        if (this.localTicker) {
            globalThis.clearInterval(this.localTicker);
            delete this.localTicker;
        }
        // in case we were still waiting for sync
        if (this.syncTimer) {
            globalThis.clearTimeout(this.syncTimer);
            delete this.syncTimer;
        }
        /** @type {Array} recent TUTTI sends and their payloads, for matching up with incoming votes and divergence alerts */
        this.tuttiHistory = [];
        /** Date.now() at end of last stepSession triggered by animation */
        this.lastAnimationEnd = 0;
        /** array of gaps between animation end and the next start.  replaced with the value true once rapid animation has been detected. */
        this.animationGapCheck = [];
        /** socket send times of recent events */
        this.rateLimitedSendTimes = [];
        /** events held back and bundled to avoid exceeding instantaneous send rate */
        this.rateLimitBuffer = [];
        this.rateLimitSoftWarned = false;
        this.rateLimitBufferWarned = false;
        this.rateLimitLastLogged = 0;
        this.payloadSizeWarned = false;
// this.stats = {};

        // controller (only) gets to subscribe to events using the shared viewId as the "subscriber" argument
        viewDomain.removeAllSubscriptionsFor(this.viewId); // in case we're recycling
        viewDomain.addSubscription(this.viewId, "__peers__", this.viewId, data => displayStatus(`users now ${data.count}`), "oncePerFrameWhileSynced");
        // "leaving" is set in session.js if we are leaving by user's request (rather than going dormant/reconnecting)
        if (!this.leaving) App.showSyncWait(true); // enable (i.e., not synced)
    }

    /** @type {String} the session id (same for all replicas running with same options on the same app version) */
    get id() { return this.vm ? this.vm.id : this.sessionSpec.id; }

    /** @type {String} the persistent id (same for all replicas with same options across app versions) */
    get persistentId() { return this.sessionSpec.persistentId; }

    /** @type {String} identifies Croquet version and app code */
    get versionId() { return this.sessionSpec.codeHash; }

    /** @type {Number} the reflector time extrapolated beyond last received tick */
    get extrapolatedTime() { return Date.now() - this.extrapolatedTimeBase; }

    /** @type {Boolean} if true, sends to the reflector are disabled */
    get viewOnly() { return this.sessionSpec.viewOnly; }

    /**  @type {Number} how many ms need to be simulated to catch up to latest time from the reflector */
    get backlog() { return this.vm ? this.reflectorTime - this.vm.time : 0; }

    /** @type {Number} how many ms passed since we received something from reflector */
    get starvation() { return Date.now() - this.lastReceived; }

    /**  @type {Number} how many ms the simulation is lagging behind extrapolated time, beyond expected tick interval */
    get lag() { return this.vm ? Math.max(0, this.extrapolatedTime - this.vm.time - this.msPerTick): 0; }

    /** @type {Number} how many ms passed since we sent a message via the reflector */
    get activity() { return Date.now() - this.lastSent; }

    /** @type {Boolean} true if our root view is up */
    get viewed() {
        return !!(this.session && this.session.view);
    }

    /** @type {Boolean} true if our connection is fine */
    get connected() { return this.connection.connected; }

    /** @type {Boolean} should the connection call leave() when disconnected? */
    get shouldLeaveWhenDisconnected() { return this.leaving || !this.canRejoinSeamlessly || this.sessionSpec.rejoinLimit === 0; }

    /** @type {Boolean} does the reflector support seamless rejoin? */
    get canRejoinSeamlessly() { return !!this.timeline; }

    checkForConnection(force) { this.connection.checkForConnection(force); }

    dormantDisconnect() {
        if (!this.connected) return;
        this.connection.dormantDisconnect();
    }

    /**
     * Initialise the controller from the sessionSpec assembled in Session.join()
     * - the vm/session id is created from `name` and
     *   a hash of registered options and source code
     *
     * @param {String} name - A (human-readable) name for the session/room
     * @param {Object} sessionSpec - Spec for the session
     * @param {Function} sessionSpec.initFn - the vm initializer `initFn(options)`
     * @param {Function} sessionSpec.rebootModelView - for taking down and rebuilding the model (i.e., the vm) and view
     * @param {Object} sessionSpec.options - options to pass to the vm initializer
     * @param {Array<String>} sessionSpec.optionsFromUrl - names of additional app-specific vm initializer options to take from URL
     * @param {String} sessionSpec.appId - a unique identifier for an app
     * @param {String} sessionSpec.password - password for end-to-end encryption
     * @param {String} sessionSpec.viewIdDebugSuffix - suffix for viewIds to help debugging
     * @param {Number|String} sessionSpec.tps - ticks per second (can be overridden by `options.tps` or `urlOptions.tps`)
     * @param {Number} sessionSpec.autoSleep - number of seconds of being hidden to trigger dormancy (or 0 to disable)
     * @param {Object} sessionSpec.flags - features to request from the reflector
     */
    async initFromSessionSpec(sessionSpec) {
        // If we add more options here, add them to SESSION_PARAMS in session.js
        const { name: n, optionsFromUrl, password, appId, apiKey, viewIdDebugSuffix } = sessionSpec;
        const name = appId ? `${appId}/${n}` : n;
        if (viewIdDebugSuffix) this.viewId = this.viewId.replace(/_.*$/, "") + '_' + encodeURIComponent(("" + viewIdDebugSuffix).slice(0, 16))
            .replace(/[^a-z0-9]/ig, c => `_${c === '%' ? "" : c.charCodeAt(0).toString(16).toUpperCase()}`); // ensure only a-z0-9_ in suffix
        // root model options are only those explicitly requested by app
        const options = {...sessionSpec.options};
        if (optionsFromUrl) for (const key of optionsFromUrl) {
            if (key in urlOptions) options[key] = urlOptions[key];
        }
        // gather additional properties that are hashed as part of deriving session ID
        const params = {};
        for (const key of [ "hashOverride" ]) {
            if (key in urlOptions) params[key] = urlOptions[key];
            else if (key in sessionSpec) params[key] = sessionSpec[key];
        }
        this.key = PBKDF2(password, "", { keySize: 256/32 });
        const persistentId = await hashNameAndOptions(name, options);
        const { developerId, token } = await this.verifyApiKey(apiKey, appId, persistentId);
        const { id, codeHash, computedCodeHash } = await hashSessionAndCode(persistentId, developerId, params, CROQUET_VERSION);
        this.tove = await this.encrypt(id);
        if (DEBUG.session) console.log(`Croquet session "${name}":
        sessionId=${id}${appId ? `
        persistentId=${persistentId}` : ""}
        versionId=${codeHash === computedCodeHash ? codeHash : `${codeHash} (specified in hashOverride)
        versionId=${computedCodeHash} (computed)`}
        viewId=${this.viewId}`);

        // eventRateLimit and other (trivially) derived settings
        this.eventRateLimit = sessionSpec.eventRateLimit; // max instantaneous send rate per second
        this.eventHistoryLimit = this.eventRateLimit; // warn user if this many sends recorded in under a second
        this.eventMaxBundles = this.eventRateLimit; // disconnect app if more than this many message bundles are waiting

        this.sessionSpec = { ...sessionSpec, options, name, id, persistentId, developerId, token, codeHash, computedCodeHash };

        const { msPerTick, multiplier } = this.getTickAndMultiplier();
        this.msPerTick = msPerTick;
        this.tickMultiplier = multiplier;

        this.setUpActivityChecks();
    }

    /**
     * Join or create a session by connecting to the reflector
     */
    async establishSession() {
        // invoked only from session's rebootModelView, under the following circs:
        //  a. on initial session setup
        //  b. on reboot following a leave() triggered by a disconnection (through connectionInterrupted)
        //  c. on reboot following a leave() triggered by SYNC when rejoin cannot proceed seamlessly
        // it doesn't return until the session is successfully joined - however many
        // connections/disconnections happen along the way.

        // reset sessionSpec.snapshot to a dummy in preparation for install()
        // (its dummy status is detected by lack of a modelsById property)
        const { id, persistentId, codeHash } = this.sessionSpec;
        this.sessionSpec.snapshot = { id, time: 0, meta: { id, persistentId, codeHash, created: (new Date()).toISOString() } };
        const joined = new Promise(resolve => this.sessionSpec.sessionJoined = resolve);
        this.checkForConnection(false); // ensure connected unless we're blocked (e.g., in dormant state)
        if (DEBUG.session) console.log(id, "waiting for SYNC");
        await joined; // resolved in SYNC after installing the vm and replaying any messages
    }

    /** fetch developerId from sign function via meta protocol */
    async verifyApiKey(apiKey, appId, persistentId) {
        try {
            const url = SIGN_SERVER;
            const response = await fetch(`${url}/join?meta=login`, {
                method: "GET",
                mode: "cors",
                headers: {
                    "X-Croquet-Auth": apiKey,
                    "X-Croquet-App": appId,
                    "X-Croquet-Id": persistentId,
                    "X-Croquet-Version": CROQUET_VERSION,
                    "X-Croquet-Path": (new URL(App.referrerURL())).pathname,
                },
                referrer: App.referrerURL(),
                referrerPolicy: 'no-referrer-when-downgrade',
            });
            const { error, developerId, token } = await response.json();
            if (error) throw Error(error);
            if (DEBUG.session) console.log(`Croquet: verified API key`);
            return { developerId, token };
        } catch (err) {
            throw Error(`Error verifying Croquet API key: ${err.message}`);
        }
    }

    lastKnownTime(vmOrSnapshot) { return Math.max(vmOrSnapshot.time, vmOrSnapshot.externalTime); }

    takeSnapshot() {
        // !!! THIS IS BEING EXECUTED INSIDE THE SIMULATION LOOP!!!
        const snapshot = this.vm.snapshot();
        const time = this.lastKnownTime(snapshot);
        const seq = snapshot.externalSeq;
        snapshot.meta = {
            ...this.sessionSpec.snapshot.meta,
            options: this.sessionSpec.options,
            time,
            seq,
            date: (new globalThis.CroquetViewDate()).toISOString(), // mar 2022: this is now running in Model code
            host: NODE ? "localhost" : window.location.hostname,
            sdk: CROQUET_VERSION,
        };
        delete snapshot.meta.hash; // old hash is invalid
        return snapshot;
    }

    takeSnapshotHandleErrors() {
        // !!! THIS IS BEING EXECUTED INSIDE THE SIMULATION LOOP!!!

        let start, ms, snapshot;
        try {
            start = Stats.begin("snapshot");
            snapshot = this.takeSnapshot();
        } catch (error) {
            displayAppError("snapshot", error);
            return null;
        } finally {
            ms = Stats.end("snapshot") - start;
        }
        if (DEBUG.snapshot) console.log(this.id, `snapshot taken in ${Math.ceil(ms)} ms`);
        return snapshot;
    }

    // we have spent a certain amount of CPU time on simulating, so schedule a snapshot
    scheduleSnapshot() {
        // abandon if this call (delayed by up to 2s - possibly more, if browser is busy)
        // has been overtaken by a poll initiated by another client.  or if the controller
        // has been reset, or we're disconnected, or viewOnly.
        if (!this.connected || !this.vm || this.viewOnly) return;

        const now = this.vm.time;
        const sinceLast = now - this.vm.lastSnapshotPoll;
        if (sinceLast < 5000) {
            if (DEBUG.snapshot) console.log(`not requesting snapshot poll (${sinceLast}ms since poll scheduled)`);
            return;
        }

        const message = new Message(now, 0, "_", "handlePollForSnapshot", []);
        // tell reflector only to reflect this message if no message with same ID has been sent in past 5000ms (wall-clock time)
        this.sendTagged(message, { debounce: SNAPSHOT_POLL_DEBOUNCE, msgID: "pollForSnapshot" });
        if (DEBUG.snapshot) console.log(this.id, "requesting snapshot poll via reflector");
    }

    handlePollForSnapshot(time) {
        // !!! THIS IS BEING EXECUTED INSIDE THE SIMULATION LOOP!!!
        // !!! IT MUST NOT MODIFY VM !!!

        if (this.synced !== true || this.viewOnly) {
            // not going to vote, so don't waste time on creating the hash
            this.triggeringCpuTime = null; // ...though unlikely to have been set
            return;
        }

        const localCpuTime = this.triggeringCpuTime || this.cpuTime;
        this.triggeringCpuTime = null;
        this.cpuTime = 0;

        let start, voteData, ms;
        try {
            start = Stats.begin("snapshot");
            voteData = {
                cpuTime: localCpuTime,
                hash: this.vm.getSummaryHash(),
                viewId: this.viewId,
            };
        } catch (error) {
            displayAppError("snapshot", error);
            return;
        } finally {
            ms = Stats.end("snapshot") - start;
            // exclude snapshot time from cpu time for logic in this.simulate()
            this.cpuTime -= ms;  // give ourselves a time credit for the non-simulation work
        }
        if (DEBUG.snapshot) console.log(this.id, `Summary hashing took ${Math.ceil(ms)}ms`);

        // sending the vote is handled asynchronously, because we want to add a view-side random()
        Promise.resolve().then(() => this.pollForSnapshot(time, voteData));
    }

    pollForSnapshot(time, voteData) {
        voteData.cpuTime += Math.random(); // fuzzify by 0-1ms to further reduce [already minuscule] risk of exact agreement.  NB: this is a view-side random().
        if (DEBUG.snapshot) console.log(this.id, "sending snapshot vote", voteData);
        this.sendTutti({ time, topic: "snapshot", data: voteData, tallyTarget: ["handleSnapshotVote"] });
    }

    handleSnapshotVote(data) {
        // !!! THIS IS BEING EXECUTED INSIDE THE SIMULATION LOOP!!!
        // !!! IT MUST NOT MODIFY VM !!!

        if (this.synced !== true) {
            if (DEBUG.snapshot) console.log(this.id, "Ignoring snapshot vote during sync");
            return;
        }

        const { tally } = data;

        if (DEBUG.snapshot) console.log(this.id, "received snapshot votes", tally);

        const { numberOfGroups, shouldUpload, dissidentFlag } = this.analyzeTally(tally, "cpuTime");
        if (numberOfGroups > 1) console.error(this.id, `Session diverged! Snapshots fall into ${numberOfGroups} groups`);
        if (shouldUpload) {
            const snapshot = this.takeSnapshotHandleErrors();
            // switch out of the simulation loop
            if (snapshot) Promise.resolve().then(() => this.uploadSnapshot(snapshot, dissidentFlag));
        }
    }

    analyzeTally(tally, timeProperty) {
        // !!! THIS IS BEING EXECUTED INSIDE THE SIMULATION LOOP!!!

        // analyse the results of a tutti vote for either a snapshot or persistence,
        // in which the tally keys are JSONified vote objects that are guaranteed to be
        // unique.
        // even if this client is not in the tally (didn't vote, or vote arrived late)
        // we still analyse the votes, because if the hashes fall into multiple groups
        // every client should log a warning.

        let shouldUpload = false;
        let dissidentFlag = null;
        const votes = [];
        const votesByHash = {};
        let ourIndex = null;
        Object.keys(tally).forEach((k, i) => {
            const vote = JSON.parse(k); // { hash, viewId } and specified time property
            votes.push(vote);

            const { hash, viewId } = vote;
            if (viewId === this.viewId) ourIndex = i;
            if (!votesByHash[hash]) votesByHash[hash] = [];
            votesByHash[hash].push(i);
            });

        const hashGroups = Object.keys(votesByHash);
        const numberOfGroups = hashGroups.length;
        let consensusIndex = 0;
        if (numberOfGroups > 1) {
            // decide consensus by majority vote; in a tie, summary hash first in
            // lexicographic order is taken as the consensus.
            hashGroups.sort((a, b) => votesByHash[b].length - votesByHash[a].length); // descending order of number of matching votes
            if (votesByHash[hashGroups[0]].length === votesByHash[hashGroups[1]].length) {
                if (DEBUG.snapshot) console.log(this.id, `Deciding consensus by tie-break`);
                if (hashGroups[1] < hashGroups[0]) consensusIndex = 1;
            }
        }
        const consensusHash = hashGroups[consensusIndex];

        // figure out whether this client should do the upload for the group (if any)
        // that it's in.
        if (ourIndex !== null) {
            const ourHash = votes[ourIndex].hash;
            const clientIndices = votesByHash[ourHash];
            if (clientIndices.length > 1) clientIndices.sort((a, b) => votes[a][timeProperty] - votes[b][timeProperty]); // ascending order
            if (clientIndices[0] === ourIndex) {
                shouldUpload = true;
                if (ourHash !== consensusHash) dissidentFlag = { groupVotes: clientIndices.length, allVotes: votes.length };
            }
        }

        return { numberOfGroups, shouldUpload, dissidentFlag };
    }

    snapshotPath(time, seq, hash) {
        // snapshot time is full precision. for storage name, we use full ms.
        const paddedTime = Math.ceil(time).toString().padStart(10, '0');
        const { appId, persistentId, codeHash, apiKey } = this.sessionSpec;
        if (!apiKey) return `snapshots/${this.id}/${paddedTime}_${seq}-${hash}.snap`;
        return `apps/${appId}/snap/${codeHash}/${persistentId}.${this.id}/${paddedTime}_${seq}.${hash}`;
    }

    hashSnapshot(snapshot) {
        // returns a Promise if hash isn't available yet
        if (snapshot.meta.hash) return snapshot.meta.hash;
        if (!snapshot.meta.hashPromise) {
            snapshot.meta.hashPromise = new Promise(resolve => {
                // exclude meta data, which has the current (real-world) time in it
                const snapshotWithoutMeta = {...snapshot};
                delete snapshotWithoutMeta.meta;
                hashString(JSON.stringify(snapshotWithoutMeta))
                .then(hash => {
                    snapshot.meta.hash = hash;
                    delete snapshot.meta.hashPromise;
                    resolve(hash);
                    });
                });
        }
        return snapshot.meta.hashPromise;
    }

    uploadServer() {
        // normal case with API keey
        let url = SIGN_SERVER;
        // we should always have an apiKey, just keeping the code for now
        if (!this.sessionSpec.apiKey) url = OLD_UPLOAD_SERVER;
        // still allow overrides (untested recently)
        if (typeof urlOptions.files === "string") {
            url = urlOptions.files;
            if (url.endsWith('/')) url = url.slice(0, -1);
        }
        return url;
    }

    /* upload a snapshot to the file server, optionally with a dissident argument that the reflector can interpret as meaning that this is not the snapshot to serve to new clients */
    async uploadSnapshot(snapshot, dissidentFlag=null) {
        await this.hashSnapshot(snapshot);
        const start = Stats.begin("snapshot");
        const content = JSON.stringify(snapshot);
        const stringMS = Stats.end("snapshot") - start;
        if (DEBUG.snapshot) console.log(this.id, `snapshot stringified (${content.length} bytes) in ${Math.ceil(stringMS)}ms`);

        const {time, seq, hash} = snapshot.meta;
        const socket = this.connection.socket;
        try {
            const url = await this.uploadEncrypted({
                content,
                path: this.snapshotPath(time, seq, hash),
                key: this.key,
                gzip: true,
                debug: DEBUG.snapshot,
                what: "snapshot",
            });
            if (this.connection.socket !== socket) { console.warn(this.id, "Controller was reset while trying to upload snapshot"); return false; }
            this.announceSnapshotUrl(time, seq, hash, url, dissidentFlag);
            return true;
        } catch (e) { console.error(this.id, "Failed to upload snapshot"); return false; }
    }

    // was sendSnapshotToReflector
    announceSnapshotUrl(time, seq, hash, url, dissidentFlag) {
        if (DEBUG.snapshot) {
            let logProps = `time: ${time}, seq: ${seq}, hash: ${hash}`;
            if (dissidentFlag) logProps += ", as dissident; " + JSON.stringify(dissidentFlag);
            console.log(this.id, `sending snapshot url to reflector (${logProps}): ${url}`);
        }
        try {
            this.connection.send(JSON.stringify({
                id: this.id,
                action: 'SNAP',
                args: {time, seq, hash, url, dissident: dissidentFlag},
            }));
        } catch (e) {
            console.error("ERROR while sending", e);
        }
    }

    async downloadEncrypted({url, gzip, key, debug, json, what}) {
        // TODO: move to worker
        if (url.startsWith(OLD_UPLOAD_SERVER)) url = url.replace(OLD_UPLOAD_SERVER, OLD_DOWNLOAD_SERVER);
        let timer = Date.now();
        const response = await fetch(url, {
            method: "GET",
            mode: "cors",
            headers: {
                "X-Croquet-App": this.sessionSpec.appId,
                "X-Croquet-Id": this.sessionSpec.persistentId,
                "X-Croquet-Session": this.sessionSpec.id,
                "X-Croquet-Version": CROQUET_VERSION,
            },
            referrer: App.referrerURL(),
        });
        const encrypted = await response.arrayBuffer();
        if (debug) console.log(this.id, `${what} fetched (${encrypted.byteLength} bytes) in ${-timer + (timer = Date.now())}ms`);
        const decrypted = this.decryptBinary(encrypted, key); // Uint8Array
        if (debug) console.log(this.id, `${what} decrypted (${decrypted.length} bytes) in ${-timer + (timer = Date.now())}ms`);
        const uncompressed = gzip ? pako.inflate(decrypted) : decrypted;
        if (debug && gzip) console.log(this.id, `${what} inflated (${uncompressed.length} bytes) in ${-timer + (timer = Date.now())}ms`);
        return json ? JSON.parse(new TextDecoder().decode(uncompressed)) : uncompressed;
    }

    /** upload string or array buffer as binary encrypted, optionally gzipped
     *
     * if path contains %HASH% it will be replaced by the hash after encryption
     */
    async uploadEncrypted({content, path, key, gzip, keep, debug, what}) {
        // leave actual work to our UploadWorker
        const buffer = typeof content === "string" ? new TextEncoder().encode(content).buffer : content;
        const transfer = keep ? undefined : [buffer];
        const keyBase64 = typeof key === "string" ? key : Base64.stringify(key);
        const { apiKey, appId, persistentId } = this.sessionSpec;
        const job = ++UploadJobs;
        return new Promise( (resolve, reject) => {
            // subtle difference in available methods
            const adder = NODE ? "addListener" : "addEventListener";
            const remover = NODE ? "removeListener" : "removeEventListener";
            UploadWorker.postMessage({
                job,
                cmd: "uploadEncrypted",
                server: this.uploadServer(),
                path,
                apiKey,
                buffer,
                keyBase64,
                gzip,
                referrer: App.referrerURL(),
                id: this.id,
                appId,
                persistentId,
                CROQUET_VERSION,
                debug,
                what,
            }, transfer);
            const onmessage = msg => {
                if (job !== msg.data.job) return; // will be dealt with by that job's listener
                const {url: urlWithHash, ok, status, statusText} = msg.data;
                UploadWorker[remover]("message", onmessage);
                if (ok) resolve(urlWithHash);
                else reject(Error(`${status}: ${statusText}`));
            };
            try {
            // UploadWorker.addEventListener("message", onmessage);
            UploadWorker[adder]("message", onmessage);
            } catch (e) { console.log("failed to add listener", e); }
        });
    }

    persistentPath(hash) {
        const { appId, persistentId } = this.sessionSpec;
        return `apps/${appId}/${persistentId}/save/${hash}`;
    }

    pollForPersist(vmTime, persistTime, persistentString, persistentHash, ms) {
        if (!this.synced) return; // ignore during fast-forward
        if (!this.sessionSpec.appId) throw Error("Persistence API requires appId");

        const ourVote = {
            viewId: this.viewId,                // to identify our own vote
            hash: persistentHash,               // if this differs, each group will upload
            ms: ms + Math.random() * 0.001,     // for sorting within a group, plus add a tiny bit of randomness
            };
        const localContext = { persistTime, persistentHash, persistentString }; // will be supplied with the tally
        if (DEBUG.snapshot) console.log(this.id, `sending persistence vote for time @${persistTime}`, ourVote);
        this.sendTutti({ time: vmTime, topic: "persist", data: ourVote, localContext, tallyTarget: ["handlePersistVote"] });
    }

    async handlePersistVote(data) {
        // !!! THIS IS BEING EXECUTED INSIDE THE SIMULATION LOOP!!!

        const { tally, localContext } = data;
        if (DEBUG.snapshot) {
            const tookPart = !!localContext;
            const timeString = tookPart ? `for time @${localContext.persistTime}` : "that we didn't participate in";
            console.log(this.id, `received persistence vote ${timeString}`, tally);
        }

        const { numberOfGroups, shouldUpload, dissidentFlag } = this.analyzeTally(tally, "ms");
        if (numberOfGroups > 1) console.warn(this.id, `Persistence records fall into ${numberOfGroups} groups`);
        if (!shouldUpload || !localContext) return;

        const { persistTime, persistentHash, persistentString } = localContext;
        const url = await this.uploadEncrypted({
            path: this.persistentPath(persistentHash),
            content: persistentString,
            key: this.key,
            gzip: true,
            debug: DEBUG.snapshot,
            what: "persistent data",
        });
        if (DEBUG.snapshot) {
            const logProps = dissidentFlag ? ` (as dissident; ${JSON.stringify(dissidentFlag)})` : "";
            console.log(this.id, `sending persistent data url to reflector${logProps}: ${url}`);
        }
        try {
            this.connection.send(JSON.stringify({
                id: this.id,
                action: 'SAVE',
                args: { persistTime, url, dissident: dissidentFlag },
            }));
        } catch (e) {
            console.error("ERROR while sending", e);
        }
    }

    // convert a message generated by the reflector itself to our own format
    convertReflectorMessage(msg) {
        // default to do nothing
        let selector = "noop";
        let args = [];
        // build message
        switch (msg[2].what) {
            case "users": {
                // get arguments
                const {joined, left, active, total} = msg[2];
                this.users = active;
                this.usersTotal = total;
                // create event
                const scope = "__VM__";
                const event = "__peers__";
                const data = {entered: joined||[], exited: left||[], count: active};
                // create event message
                selector = "publishFromModelOnly";
                args = [scope, event, data];

                // also immediately publish as view event, which this controller will
                // have subscribed to (in its constructor).
                viewDomain.handleEvent(this.viewId + ':' + event, data);
                break;
            }
            case "tally": {
                // an old reflector will send a property tuttiSeq containing the dummy
                // sequence number that we provided; a new reflector will notice that we
                // provided a tuttiKey, and will send just that.
                // the reflector's message also contains the tally, and optionally a tallyTarget
                // message to be dispatched by the VM.
                const { tuttiSeq, tuttiKey, tally, tallyTarget, missingClients } = msg[2];
                if ((DEBUG.messages || DEBUG.snapshot) && missingClients) console.log(`${missingClients} ${missingClients === 1 ? "client" : "clients"} failed to participate in tally ${tuttiKey || tuttiSeq}`); // purely for information
                selector = "handleTuttiResult";
                args = [ { tuttiSeq, tuttiKey, tally, tallyTarget } ];
                break;
            }
            // no default
        }
        // convert to serialized state
        const message = new Message(0, 0, "_", selector, args);
        msg[2] = message.asState()[2];
    }

    handleTuttiResult(data) {
        // !!! THIS IS BEING EXECUTED INSIDE THE SIMULATION LOOP!!!
        const { tuttiSeq, tuttiKey, tally, tallyTarget } = data;
        const finder = tuttiKey
            ? (hist => hist.tuttiKey === tuttiKey)
            : (hist => hist.dummyTuttiSeq === tuttiSeq);
        const tuttiIndex = this.tuttiHistory.findIndex(finder);
        const local = tuttiIndex !== -1 && this.tuttiHistory.splice(tuttiIndex, 1)[0];
        // if we have a record of supplying a vote for this TUTTI, retrieve our contribution and any local context
        let localPayload = null, localContext = null;
        if (local) {
            localPayload = local.payload;  // stringified
            localContext = local.localContext;
        }
        if (tallyTarget) {
            const [selector, ...optionalTopic] = tallyTarget;
            const args = [ ...optionalTopic, { tally, localPayload, localContext } ];
            const message = new Message(0, 0, "_", selector, args);
            this.vm.verifyExternal(message); // may throw
            message.executeOn(this.vm, true); // true => nested
        }
    }

    // handle messages from reflector
    async receive(action, args) {
        const prevReceived = this.lastReceived;
        this.lastReceived = this.connection.lastReceived;
        switch (action) {
            case 'SYNC': {
                // We are joining a session.
                this.syncReceived = true; // from this point, any disconnection implies a leave()
                this.clearSyncReceiptTimeout();

                Controllers.add(this);

                const {messages, url, persisted, time, seq, /* snapshotTime, */ snapshotSeq, tove, reflector, flags} = args;
                // check that we are able to decode a shared secret (unless it's our own)
                if (tove && tove !== this.tove) try {
                    // decrypt will throw if it can't decrypt, which is the expected result if joining with a wrong password
                    if (this.decrypt(tove) !== this.id) throw Error("wrong sessionId in tove?!");
                } catch (err) {
                    this.connection.closeConnectionWithError('SYNC', Error(`failed to decrypt session secret: ${err.message}`), 4200); // do not retry
                    return;
                }
                const timeline = args.timeline || args.reflectorSession; // renamed "reflectorSession" to "timeline"
                this.flags = flags || {};
                const persistedOrSnapshot = persisted ? "persisted session" : "snapshot";
                if (DEBUG.session) console.log(this.id, `received SYNC from ${reflector} reflector: time ${time}, ${messages.length} messages, ${persistedOrSnapshot} ${url || "<none>"}`);
                // if we are rejoining, check if we can do that seamlessly without taking down the view
                // meaning we have all the messages we missed while disconnected
                let rejoining = !!this.vm;
                if (rejoining) {
                    // In theory we could try to preserve unsimulated messages but that would complicate the logic
                    // considerably, and only help in the rather unlikely case of a snapshot being taken while simulation
                    // was backlogged, in which case it might be better to start from the new snapshot anyways.
                    // Instead, we just make make sure no old messages are hanging around:
                    this.networkQueue.length = 0;
                    // old reflector does not send seq, snapshotSeq, timeline, cannot rejoin
                    const sameSession  = !!timeline && timeline === this.timeline;
                    const firstMessage = messages[0];
                    const newest = seq;
                    const oldest = snapshotSeq !== undefined ? snapshotSeq
                        : firstMessage ? firstMessage[1] : newest;
                    if (DEBUG.messages) console.log(this.id, `rejoin: we have #${this.vm.seq} SYNC has #${oldest}-#${newest}`);
                    let seamlessRejoin = sameSession         // must be same timeline (in case we are connected to stateless reflector)
                        && inSequence(oldest, this.vm.seq)   // there must be no gap between our last message and the first synced message
                        && inSequence(this.vm.seq, newest)   // the reflector state must not be older than our vm (presumably due to reflector crash and restart)
                        && time >= this.reflectorTime; // similarly, the reflector must not be providing an earlier time than we have already seen
                    if (seamlessRejoin) {
                        // rejoin appears safe.  figure out what messages (if any) in the SYNC have already
                        // been processed here.
                        let toDiscard = 0;
                        if (firstMessage && inSequence(firstMessage[1], this.vm.seq)) {
                            toDiscard = this.vm.seq - firstMessage[1] + 1 >>> 0; // 32 bit difference (!)
                        }

                        // if the messages to be processed to catch up include a 'users' event
                        // reporting that this view has left, rejoin is not safe after all.
                        // this is a conservative check; it's possible that the event represents
                        // a harmless and ignorable view-exit for a duplicate connection.  but
                        // attempting to replicate the VM's extraConnections logic here feels
                        // like overkill.
                        for (let i = toDiscard; seamlessRejoin && i < messages.length; i++) {
                            const payload = messages[i][2];
                            if (typeof payload !== "string" && payload.what === "users" && payload.left && payload.left.includes(this.viewId)) {
                                if (DEBUG.session) console.log(this.id, "reflector reports that this view has left");
                                seamlessRejoin = false;
                            }
                        }

                        if (seamlessRejoin && toDiscard) {
                            // we're going ahead with seamless rejoin.  discard the duplicates found above.
                            if (DEBUG.messages) console.log(this.id, `rejoin: discarding ${toDiscard} messages #${firstMessage[1]}-#${this.vm.seq}`);
                            messages.splice(0, toDiscard);
                        }
                    }
                    if (seamlessRejoin) {
                        // send out messages we buffered while disconnected
                        if (this.sendBuffer.length > 0) {
                            const sends = this.sendBuffer;
                            this.sendBuffer = [];   // if we get disconnected again, sends will be re-buffered
                            if (DEBUG.session) console.log(this.id, `rejoin: sending ${sends.length} messages buffered while disconnected`);
                            for (const f of sends) f();
                        }
                        // proceed to enqueue the messages we missed while disconnected
                    } else {
                        // one of the checks above has found that seamless rejoin cannot happen.  reboot.
                        if (DEBUG.session) console.log(this.id, "cannot rejoin seamlessly; rebooting model/view");
                        this.leave(true); // keep controller but reset it, nulling out the vm.  now runs straight through to the end of establishSession.
                        rejoining = false;
                    }
                }
                // enqueue all messages now because the reflector will start sending more messages
                // while we are waiting for the snapshot.
                // if any conversion of custom reflector messages is to be done, do it before
                // waiting for the snapshot to arrive (because there might be some meta-processing
                // that happens immediately on conversion; this is the case for "users" messages)
                const messagesSinceSync = this.networkQueue; // in case we RECVed during the await above
                this.networkQueue = [];
                for (const msg of messages) {
                    if (typeof msg[2] !== "string") {
                        this.convertReflectorMessage(msg);
                    } else try {
                        msg[2] = this.decryptPayload(msg[2])[0];
                    } catch (err) {
                        this.connection.closeConnectionWithError('SYNC', Error(`failed to decrypt message: ${err.message}`), 4200); // do not retry
                        return;
                    }
                    if (DEBUG.messages) console.log(this.id, "received in SYNC " + JSON.stringify(msg));
                    this.networkQueue.push(msg);
                }
                this.networkQueue.push(...messagesSinceSync);
                if (time > this.reflectorTime) this.timeFromReflector(time, "reflector");
                // if we were rejoining, then our work is done here: we got all the missing messages
                if (rejoining) {
                    if (DEBUG.session) console.log(this.id, "seamless rejoin successful");
                    this.sessionSpec.sessionJoined();
                    return;
                }
                this.timeline = timeline || ""; // stored only on initial connection
                // otherwise we need go to work
                if (DEBUG.snapshot && url) console.log(`${this.id} fetching ${persistedOrSnapshot} ${url}`);
                let data;
                if (url) try {
                    data = await this.downloadEncrypted({url, gzip: true, key: this.key, debug: DEBUG.snapshot, json: true, what: persistedOrSnapshot});
                } catch (err) {
                    this.connection.closeConnectionWithError('SYNC', Error(`failed to fetch ${persistedOrSnapshot}: ${err.message}`), 4200); // do not retry.  synchronously nulls out socket.
                    return;
                }
                if (!this.connected) { console.log(this.id, "disconnected during SYNC"); return; }
                if (persisted) {
                    // run initFn() with persisted data, if any
                    this.install(data);
                } else {
                    if (data) this.sessionSpec.snapshot = data;  // set snapshot for building the vm
                    this.install();  // will run initFn() if no snapshot
                }
                // after install() sets this.vm, the main loop may also trigger simulation
                if (DEBUG.session) console.log(`${this.id} fast-forwarding from ${Math.round(this.vm.time)}`);
                // execute pending events, up to (at least) our own view-join
                const success = await new Promise(resolve => {
                    this.fastForwardHandler = caughtUp => {
                        if (!this.connected || !this.vm) {
                            console.log(this.id, "disconnected during SYNC fast-forwarding");
                            resolve(false);
                        } else if (caughtUp === "error") {
                            resolve(false);
                        } else if (caughtUp && this.viewId in this.vm.views) {
                            resolve(true);
                        }
                        };
                    Promise.resolve().then(() => this.stepSession("fastForward", { budget: MAX_SIMULATION_MS })); // immediate but not in the message handler
                    });
                delete this.fastForwardHandler;
                if (success && DEBUG.session) console.log(`${this.id} fast-forwarded to ${Math.round(this.vm.time)}`);
                // iff fast-forward was successful, trigger return from establishSession().
                // otherwise, in due course we'll reconnect and try again.  it can keep waiting.
                if (success) this.sessionSpec.sessionJoined();
                return;
            }
            case 'RECV': {
                // We received a message from reflector.
                // Put it in the queue, and set time.
                // Actual processing happens in main loop.
                const msg = args;
                msg[1] >>>= 0; // make sure it's uint32 (reflector used to send int32)
                // the reflector might insert messages on its own, indicated by a non-string payload
                // we need to convert the payload to the message format this client is using
                if (typeof msg[2] !== "string") {
                    if (DEBUG.messages) console.log(this.id, "received META " + JSON.stringify(msg));
                    this.convertReflectorMessage(msg);
                    if (DEBUG.messages) console.log(this.id, "converted to " + JSON.stringify(msg));
                } else try {
                    const [payload, viewId, lastSent] = this.decryptPayload(msg[2]);
                    msg[2] = payload;
                    // if we sent this message, add it to latency statistics
                    if (viewId === this.viewId) this.addToStatistics(lastSent, this.lastReceived);
                    if (DEBUG.messages) console.log(this.id, "received " + JSON.stringify(msg));
                } catch (err) {
                    this.connection.closeConnectionWithError("RECV", Error(`failed to decrypt message: ${err.message}`), 4200); // do not retry
                    return;
                }
                this.networkQueue.push(msg);
                let rawTime;
                if (this.flags.rawtime) rawTime = msg[msg.length - 1];
                this.timeFromReflector(msg[0], "reflector", rawTime);
                if (this.simulateIfNeeded) Promise.resolve().then(() => this.simulateIfNeeded()); // immediate but not in the message handler
                return;
            }
            case 'TICK': {
                // We received a tick from reflector.
                // Just set time so main loop knows how far it can advance.
                if (!this.vm) return; // ignore ticks before we are simulating (this also catches any ticks received during reboot)
                const time = (typeof args === "number") ? args : args.time;
                if (DEBUG.ticks) {
                    const expected = prevReceived && this.lastReceived - prevReceived - this.msPerTick * this.tickMultiplier | 0;
                    console.log(this.id, `Controller received TICK ${time} ${Math.abs(expected) < 5 ? "on time" : expected < 0 ? "early" : "late"} (${expected} ms)`);
                }
                this.timeFromReflector(time, "reflector");
                if (this.tickMultiplier > 1) this.multiplyTick(time);
                if (this.simulateIfNeeded) Promise.resolve().then(() => this.simulateIfNeeded()); // immediate but not in the message handler
                return;
            }
            case 'INFO': {
                // information the reflector wants us to know
                // for the moment just show it
                const { msg, options } = args;
                App.showMessage(msg, options);
                return;
            }
            case 'REQU': {
                // reflector requests a snapshot
                if (DEBUG.snapshot) console.log("received REQU (snapshot request) from reflector");
                this.cpuTime = 12345; // a recognisable number, greater than SNAPSHOT_EVERY
                return;
            }
            default: console.warn("Unknown action:", action, args);
        }
    }

    // create the VirtualMachine for this Controller, based on the sessionSpec
    install(persistentData) {
        const start = Date.now();
        const {snapshot, initFn, options} = this.sessionSpec;
        const [verb, noun] = snapshot.modelsById ? ["deserializ", "snapshot"] : ["initializ", "root model"];
        if (DEBUG.session) console.log(`${this.id} ${verb}ing ${noun}`);
        let newVM = new VirtualMachine(snapshot, () => {
            try { return initFn(options, persistentData); }
            catch (error) {
                displayAppError("init", error, "fatal");
                throw error; // unrecoverable.  bring the whole tab to a halt.
            }
        });
        if (DEBUG.session || (DEBUG.snapshot && snapshot.modelsById)) {
            console.log(`${this.id} ${noun} ${verb}ed in ${Date.now() - start}ms`);
        }
        if (DEBUG.initsnapshot && !snapshot.modelsById) {
            // exercise serializer if we came from initFn
            if (DEBUG.snapshot) console.log(`${this.id} exercising snapshot and restore after init()`);
            let initialSnapshot = null;
            try { initialSnapshot = JSON.stringify(newVM.snapshot()); }
            catch (error) {
                displayAppError("initial snapshot", error, "fatal");
                throw error; // unrecoverable.  bring the whole tab to a halt
            }
            try {
                newVM = new VirtualMachine(JSON.parse(initialSnapshot), () => initFn(options));
            } catch (error) {
                displayAppError("initial snapshot resume", error, "fatal");
                throw error; // unrecoverable.  bring the whole tab to a halt
            }
        }
        // our time is the latest of this.reflectorTime (we may have received a tick already) and the vm time in the snapshot
        const vmTime = this.lastKnownTime(newVM);
        this.reflectorTime = Math.max(this.reflectorTime, vmTime);
        this.setVM(newVM); // make this our vm
    }

    setVM(vm) {
        this.vm = vm;
        this.vm.controller = this;
    }

    // // create a VM in its initial state
    // createCleanVM() {
    //     const { options, initFn } = this.sessionSpec;
    //     const snapshot = { id: this.id };
    //     return new VirtualMachine(snapshot, () => initFn(options));
    // }

    // network queue

    sendJoin() {
        this.syncReceived = false; // until SYNC is received, a dropped connection doesn't require controller.leave()
        delete this.fastForwardHandler; // in case one was left

        // cancel rejoin timeout (if any) immediately.  now that we're reconnected, it
        // would be messy to have a reboot triggered between now and the SYNC.
        if (this.rejoinTimeout) { clearTimeout(this.rejoinTimeout); this.rejoinTimeout = 0; }

        if (DEBUG.session) console.log(this.id, "Controller sending JOIN");

        const { tick, delay } = this.getTickAndMultiplier();
        const { name, codeHash, appId, apiKey, persistentId, developerId, heraldUrl, rejoinLimit, autoSleep, computedCodeHash, flags } = this.sessionSpec;

        const args = {
            name,                   // for debugging only
            apiKey,                 // undefined in old clients
            appId,                  // for sign func
            persistentId,           // for sign func
            url: App.referrerURL(), // for sign func
            sdk: CROQUET_VERSION,   // for sign func
            developerId,            // for logging
            version: VERSION,       // protocol version
            user: this.viewId,      // see vm.generateJoinExit() for getting location data
            ticks: { tick, delay },
            dormantDelay: autoSleep, // not used yet, but tells reflector this client is >= 0.5.1
            tove: this.tove,        // an encrypted message the reflector will send to every client in SYNC
            codeHash,               // for debugging only
        };
        if (heraldUrl) Object.assign(args, {
            heraldUrl,              // url to receive POST for join/leave events
        });
        if (rejoinLimit) Object.assign(args, {
            leaveDelay: rejoinLimit + 250, // delay leave events
        });
        if (computedCodeHash !== codeHash) Object.assign(args, {
            computedCodeHash,       // for debugging only
        });
        if (flags) Object.assign(args, {
            flags,                  // flags for requesting reflector features
        });

        this.connection.send(JSON.stringify({
            id: this.id,
            action: 'JOIN',
            args,
        }));

        this.syncReceiptTimeout = setTimeout(() => {
            delete this.syncReceiptTimeout;
            if (!this.syncReceived) {
                this.connection.closeConnectionWithError("join", Error("SYNC not received in time"));
            }
            }, JOIN_FAILED_DELAY);
    }

    clearSyncReceiptTimeout() {
        if (this.syncReceiptTimeout) {
            clearTimeout(this.syncReceiptTimeout);
            delete this.syncReceiptTimeout;
        }
    }

    connectionInterrupted() {
        // only need to leave if we have actually joined - or at least started
        // the work of joining, in the 'SYNC' handler
        if (!this.syncReceived) return;

        if (this.shouldLeaveWhenDisconnected) this.leave(); // including if rejoinLimit=0
        else if (!this.rejoinTimeout) {
            // set up a timeout to leave unless the connection gets restored
            // within rejoinLimit
            this.rejoinTimeout = setTimeout(() => {
                if (DEBUG.session) console.log(this.id, `rejoin timed out`);
                this.rejoinTimeout = 0;
                this.leave();
            }, this.sessionSpec.rejoinLimit);
        }
    }

    // either the connection has been broken (and seamless rejoin is not
    // available), or the reflector has sent LEAVE.
    // reset the controller.  unless keepController is true, remove it from
    // the Controllers set (used for keepAlive, and for accessing the data
    // upload/download functions from Data).
    leave(keepController=false) {
        const { rebootModelView } = this.sessionSpec;
        this.reset();
        if (DEBUG.session) console.log(this.id, `resetting ${keepController ? "(but keeping)" : "and discarding"} controller`);
        if (!keepController) Controllers.delete(this);   // after reset so it does not re-enable the SYNC overlay
        if (!this.sessionSpec) throw Error("do not discard sessionSpec!");
        rebootModelView(); // if controller.leaving is set (user has triggered Session.leave, or session has errored), rMV will bail out after destroying the view
    }

    async encrypt(plaintext) {
        const iv = WordArray.random(16);
        const ciphertext = AES.encrypt(plaintext, this.key, {
            iv,
            // padding: Pkcs7, // default
            // mode: CBC       // default
          });
        const hmac = HmacSHA256(plaintext, this.key);
        const encrypted = `${Base64.stringify(iv)}${Base64.stringify(hmac)}${ciphertext}`;
        return encrypted;
    }

    get deprecatedDefaultKey() {
        if (!DEPRECATED_DEFAULT_KEY) {
            DEPRECATED_DEFAULT_KEY = PBKDF2("THIS SHOULDN'T BE IN LOGS", "", { keySize: 256/32 });
        }
        return DEPRECATED_DEFAULT_KEY;
    }

    decrypt(encrypted, key=this.key) {
        const iv = Base64.parse(encrypted.slice(0, 24));
        const mac = Base64.parse(encrypted.slice(24, 24 + 44));
        const ciphertext = encrypted.slice(24 + 44);
        const decrypted = AES.decrypt(ciphertext, key, { iv });
        let plaintext = "";
        try { plaintext = Utf8.stringify(decrypted); } catch (err) { /* ignore */ }
        const hmac = HmacSHA256(plaintext, this.key);
        if (this.compareHmacs(mac.words, hmac.words)) return plaintext;
        if (key !== this.deprecatedDefaultKey) return this.decrypt(encrypted, this.deprecatedDefaultKey);
        throw Error("Decryption error");
    }

    decryptBinary(buffer, key) {
        const version = new TextDecoder().decode(new Uint8Array(buffer, 0, 4));
        if (typeof key === "string") key = Base64.parse(key);
        let encrypted, iv, mac, ciphertext, decrypted;
        switch (version) {
            case "CRQ0": // Base64
                encrypted = new TextDecoder().decode(buffer);
                iv = Base64.parse(encrypted.slice(4, 4 + 24));
                mac = Base64.parse(encrypted.slice(4 + 24, 4 + 24 + 44));
                ciphertext = encrypted.slice(4 + 24 + 44);
                decrypted = AES.decrypt(ciphertext, key, { iv });        // implicitly creates { ciphertext }
                break;
            case "CRQ1": // Binary
                encrypted = new Uint8Array(buffer);
                iv = WordArray.create(encrypted.subarray(4, 4 + 16));
                mac = WordArray.create(encrypted.subarray(4 + 16, 4 + 16 + 32));
                ciphertext = WordArray.create(encrypted.subarray(4 + 16 + 32));
                decrypted = AES.decrypt({ ciphertext }, key, { iv });
                break;
            default: throw Error(`${this.id} unknown encryption version ${version}`);
        }
        decrypted.clamp(); // clamping manually because of bug in HmacSHA256
        const hmac = HmacSHA256(decrypted, key);
        if (this.compareHmacs(mac.words, hmac.words)) return cryptoJsWordArrayToUint8Array(decrypted);
        if (key !== this.deprecatedDefaultKey) return this.decryptBinary(buffer, this.deprecatedDefaultKey);
        throw Error("Decryption error");
    }

    async encryptMessage(msg, viewId, sendTime) {
        const [time, seq, msgPayload] = msg.asState();
        const encryptedPayload = await this.encryptPayload([msgPayload, viewId, sendTime]);
        return [time, seq, encryptedPayload];
    }

    async encryptPayload(payload) {
        return this.encrypt(JSON.stringify(payload));
    }

    decryptPayload(encrypted) {
        return JSON.parse(this.decrypt(encrypted));
    }

    compareHmacs(fst, snd) {
        let ret = fst.length === snd.length;
        for (let i=0; i<fst.length; i++) {
            if (!(fst[i] === snd[i])) {
                ret = false;
            }
        }
        return ret;
    }

    /** send a Message to all vm replicas via reflector
     * @param {Message} msg
    */
    sendMessage(msg) {
        // SEND: Broadcast a message to all participants.
        // ignore if controller is not allowed to send, or has been reset
        if (this.viewOnly || !this.vm) return;

        const payloadLength = msg.asState()[2].length;
        if (payloadLength > PAYLOAD_LIMIT_MAX) {
            console.warn(`${this.id} Message with payload of ${payloadLength} bytes exceeds maximum ${PAYLOAD_LIMIT_MAX} and will not be sent to reflector.`);
            return;
        }
        if (!this.payloadSizeWarned && payloadLength > PAYLOAD_LIMIT_RECOMMENDED) {
            console.log(`${this.id} Message with payload of ${payloadLength} bytes being sent to reflector. Maximum recommended is ${PAYLOAD_LIMIT_RECOMMENDED}.`);
            this.payloadSizeWarned = true;
        }

        const now = Date.now();
        const times = this.rateLimitedSendTimes;
        const buffer = this.rateLimitBuffer;
        Stats.perSecondTally({ requestedMessages: 1 });

        // if there are already events in the buffer, this message has to join the queue
        if (buffer.length) {
            this.addToRateLimitBuffer(msg); // can potentially cause disconnection
            return;
        }

        let delay = 0;
        // once we have any record of recent sends, compare now to last send time.
        // postpone if closer than allowed by the maximum instantaneous rate.
        // avoid buffering if controller is being synced.
        if (times.length && this.synced) {
            const lastSend = times[times.length - 1];
            const stillToWait = 1000 / this.eventRateLimit - (now - lastSend);
            if (stillToWait > 1) delay = Math.ceil(stillToWait); // we want the timeout to be long enough to be sure to satisfy the gap
        }
        if (!delay) {
            // go ahead immediately
            this.recordRateLimitedSend(now);
            this.socketSendMessage(msg); // will be added to sendBuffer if we're currently disconnected (with the chance of a reconnect, since this.vm is still set)
            Stats.perSecondTally({ sentSingleMessages: 1, sentMessagesTotal: 1, sentPayloadTotal: payloadLength });
        } else {
            this.addToRateLimitBuffer(msg);
            setTimeout(() => this.serviceRateLimitBuffer(), delay);
        }
    }

    recordRateLimitedSend(time) {
        const times = this.rateLimitedSendTimes;
        // if controller isn't synced, don't push a duplicate time.
        const isSynced = this.synced;
        if (isSynced || !times.length || times[times.length - 1] !== time) {
            times.push(time);
            if (times.length > this.eventHistoryLimit) times.shift();
        }

        // it's not a short gap between consecutive messages that should trigger a
        // warning, but any sustained sending at the peak rate (whether or not we're
        // using the buffer).
        if (!this.rateLimitSoftWarned && times.length === this.eventHistoryLimit && time - times[0] < 1010) { // close enough
            console.warn(`${this.id} Sends to reflector are at or above recommended limit of ${this.eventHistoryLimit} within one second. Events will be bundled as necessary to keep to the limit.`);
            this.rateLimitSoftWarned = true;
        }
    }

    addToRateLimitBuffer(msg) {
        Stats.perSecondTally({ bundledMessages: 1 });
        const now = Date.now();
        // rateLimitBuffer is an array of { msgStates, totalPayload } bundles
        const msgState = msg.asState(); // [time, seq, payload]
        const payloadLength = msgState[2].length;
        const buffer = this.rateLimitBuffer;
        if (buffer.length) {
            const lastBundle = buffer[buffer.length - 1];
            const { msgStates, totalPayload } = lastBundle;
            // add until the sum of payload sizes reaches our soft limit
            if (totalPayload < PAYLOAD_LIMIT_RECOMMENDED) {
                // ok to add
                msgStates.push({ msgState, bufferTime: now });
                lastBundle.totalPayload += payloadLength;
                return;
            }
        }

        // start a new bundle
        Stats.perSecondTally({ newBundles: 1 });
        buffer.push({ msgStates: [{ msgState, bufferTime: now }], totalPayload: payloadLength });
        const buffered = buffer.length;
        if (DEBUG.session && buffered % 5 === 0 && buffered !== this.rateLimitLastLogged) {
            console.log(`${this.id} SEND rate-limit buffer grew to ${buffered} event bundles (max ${this.eventMaxBundles})`);
            this.rateLimitLastLogged = buffered;
        }
        if (buffered > this.eventMaxBundles) {
            console.error(`${this.id} Disconnecting after overflow of SEND rate-limit buffer.`);
            this.connection.closeConnectionWithError("SEND", Error(`Send rate exceeded`), 4200); // do not retry.  synchronously nulls out socket.
        } else if (!this.rateLimitBufferWarned && buffered > this.eventMaxBundles / 2) {
            console.warn(`${this.id} SEND rate-limit buffer is 50% full. If send rate does not drop, the app will be disconnected.`);
            this.rateLimitBufferWarned = true;
        }
    }

    serviceRateLimitBuffer() {
        if (!this.connected) return;

        const buffer = this.rateLimitBuffer;
        const buffered = buffer.length;
        if (!buffered) return;

        const now = Date.now();
        const minGap = 1000 / this.eventRateLimit;
        const times = this.rateLimitedSendTimes;
        if (times.length) {
            const lastSend = times[times.length - 1];
            const stillToWait = minGap - (now - lastSend);
            if (stillToWait > 0) return;
        }

        const bundle = buffer.shift();
        const { msgStates, totalPayload } = bundle; // msgStates is an array of { msgState, bufferTime }
        const events = [];
        let delay = 0;
        msgStates.forEach(m => {
            events.push(m.msgState);
            delay += now - m.bufferTime;
            });
        if (events.length === 1) {
            const msg = Message.fromState(events[0], this.vm);
            this.socketSendMessage(msg);
        } else {
            const envelope = new Message(this.vm.time, 0, "_", "handleBundledEvents", [events]);
            this.socketSendMessage(envelope);
        }
        this.recordRateLimitedSend(now);
        Stats.perSecondTally({ sentBundles: 1, sentMessagesTotal: msgStates.length, sendDelay: delay, sentBundlePayload: totalPayload, sentPayloadTotal: totalPayload });

        if (DEBUG.session && this.connected) {
            const nowBuffered = buffer.length;
            if (nowBuffered && nowBuffered % 5 === 0 && nowBuffered !== this.rateLimitLastLogged) {
                console.log(`${this.id} SEND rate-limit buffer dropped to ${nowBuffered} event bundles`);
                this.rateLimitLastLogged = nowBuffered;
            }
        }

        // if there are still entries in the buffer, schedule a timeout to
        // take another bite.
        if (buffer.length) setTimeout(() => this.serviceRateLimitBuffer(), minGap);
    }

    async socketSendMessage(msg, tags=null) {
        // get the asynchronous encoding out of the way before the check that
        // we're still connected.
        const encryptedMsg = await this.encryptMessage(msg, this.viewId, Date.now()); // [time, seq, payload]

        const description = tags ? `tagged SEND ${msg.asState()} with tags ${JSON.stringify(tags)}` : `SEND ${msg.asState()}`;

        // view sending events while connection is closing or rejoining
        if (!this.connected) {
            if (this.vm) {
                if (DEBUG.sends) console.log(this.id, `buffering ${description}`);
                this.sendBuffer.push(() => this.socketSendMessage(msg, tags));
            }
            return;
        }

        if (DEBUG.sends) console.log(this.id, `sending ${description}`);

        const toSend = {
            id: this.id,
            action: 'SEND',
            args: [...encryptedMsg, this.latency],
            };
        if (tags) toSend.tags = tags;
        this.lastSent = Date.now();
        this.connection.send(JSON.stringify(toSend));
    }

    /** send a Message to all vm replicas via reflector, subject to reflector preprocessing as determined by the tag(s)
     * @param {Message} msg
     * @param {Object} tags
    */
    async sendTagged(msg, tags) {
        // reflector SEND protocol allows for an additional tags property.
        // as of aug 2021, the only tagging is "debounce".  for example:
        //    { debounce: 1000, msgID: "pollForSnapshot" }

        // because the reflector can't see details of messages that are
        // combined into bundles, tagged messages always bypass the buffering.
        if (this.viewOnly) return;

        this.socketSendMessage(msg, tags);
    }

    /** send a TUTTI Message
     * @param {Object} spec
    */
    async sendTutti({ time, topic, data, localContext=null, firstMessage=null, wantsVote=true, tallyTarget=null }) {
        // TUTTI: Send a message that multiple clients are expected to send identically.
        // This method is called directly by system-level features that use voting (currently for snapshot
        // and persistence).  It is also invoked implicitly from handleModelEventInModel, if the
        // published event name has the #reflected suffix.
        // The reflector will optionally broadcast the first received message immediately, then
        // gather all messages up to a deadline and send a TALLY message summarising the results
        // (whatever those results, if wantsVote is true; otherwise, only if there is some divergence
        // among them).

        // When called via handleModelEventInModel for a published event scope:foo#reflected
        //  - firstMessage will be handleModelEventInModel(scope:foo) iff there is a model subscription
        //    for scope:foo
        //  - wantsVote will be true iff there is a view subscription for scope:foo#__vote.  in this case,
        //    tallyTarget will be handleModelEventInView(scope:foo#__vote)
        //  - if wantsVote is false - meaning that the tallyTarget will only be invoked if there is
        //    divergence - the tallyTarget is handleTuttiDivergence, which invokes any model-level
        //    subscription for scope:foo#divergence or, if none, prints an "uncaptured divergence" warning.

        // The optional localContext is for arbitrary values that this client wants to have at hand when
        // the vote comes in, but not to send to the reflector.  The values don't need to be serialisable.
        if (this.viewOnly) return;

        // get the asynchronous encoding out of the way before the check that
        // we're still connected.
        const encryptedMsg = firstMessage && await this.encryptMessage(firstMessage, this.viewId, Date.now()); // [time, seq, payload]
        const payload = stableStringify(data); // stable, to rule out platform differences

        // view sending events while connection is closing or rejoining
        if (!this.connected) {
            if (this.vm) {
                if (DEBUG.sends) console.log(this.id, `buffering "${topic}" TUTTI ${payload} ${firstMessage && firstMessage.asState()}`);
                this.sendBuffer.push(() => this.sendTutti({ time, topic, data, localContext, firstMessage, wantsVote, tallyTarget }));
            }
            return;
        }

        if (DEBUG.sends) console.log(this.id, `sending "${topic}" TUTTI ${payload} ${firstMessage && firstMessage.asState()}`);
        this.lastSent = Date.now();
        // jul 2021: in case we were assigned to an old reflector, we supplied a dummy
        // tuttiSeq in second place in the arg array.  as of late 2021 all deployed
        // reflectors check for a seventh-place argument instead, but will still
        // recognise a pre-0.5.1 app's second-place tuttiSeq.
        const dummyTuttiSeq = 0;
        const tuttiKey = `${topic}@${time}`;
        this.connection.send(JSON.stringify({
            id: this.id,
            action: 'TUTTI',
            args: [time, dummyTuttiSeq, payload, encryptedMsg, wantsVote, tallyTarget, tuttiKey],
        }));
        if (this.tuttiHistory.length > 100) this.tuttiHistory.shift();
        this.tuttiHistory.push({ time, tuttiKey, dummyTuttiSeq, payload, localContext });
    }

    sendLog(...args) {
        if (!this.connected) {
            if (this.vm) {
                if (DEBUG.sends) console.log(this.id, `buffering LOG`);
                this.sendBuffer.push(() => this.sendLog(...args));
            }
            return;
        }
        if (DEBUG.sends) console.log(this.id, `sending LOG`);
        if (args.length < 2) args = args[0];
        this.connection.send(JSON.stringify({ action: 'LOG', args }));
    }

    addToStatistics(timeSent, timeReceived) {
        this.latency = timeReceived - timeSent;
        if (this.latencyHistory) {
            if (this.latencyHistory.length >= 100) this.latencyHistory.shift();
            this.latencyHistory.push({time: timeReceived, ms: this.latency});
        }
    }

    get latencies() {
        if (!this.latencyHistory) this.latencyHistory = [];
        return this.latencyHistory;
    }

    /** parse tps `ticks x multiplier` ticks are from server, multiplied by locally generated ticks
     *
     * default taken from `sessionSpec.tps` unless `sessionSpec.options.tps` is present
     *
     * @returns {{
     *      msPerTick: Number,  // effective tick period in ms
     *      multiplier: Number, // local multiplier
     *      tick: Number,       // reflector tick period in ms
     *      delay: Number,      // reflector delay to account for locally produced ticks
     * }}
     */
    getTickAndMultiplier() {
        const options = this.sessionSpec.options;
        const tps = ["number", "string"].includes(typeof options.tps) ? options.tps
            : ["number", "string"].includes(typeof this.sessionSpec.tps) ? this.sessionSpec.tps
            : 20;
        const [rate, mult] = (tps + 'x').split('x').map(n => Number.parseFloat('0' + n));
        const tick = 1000 / Math.max(1/30, Math.min(60, rate));     // minimum 1 tick per 30 seconds
        const multiplier = Math.max(1, mult);      // default multiplier is 1 (no local ticks)
        let msPerTick = tick;
        let delay = 0;
        if (multiplier > 1 && !NOCHEAT) {
            msPerTick = tick / multiplier;
            delay = Math.ceil(msPerTick * (multiplier - 1));
        }
        return { msPerTick, multiplier, tick, delay };
    }

    /**
     * Process pending messages for this vm and advance simulation
     * @param {Number} deadline CPU time deadline before interrupting simulation
     * @return {Boolean} true if simulation finished before deadline
     */
    simulate(deadline) {
        if (!this.vm) return true;     // we are probably still sync-ing
        try {
            let weHaveTime = true;
            const nothingToDo = this.networkQueue.length + this.vm.messages.size === 0;
            if (nothingToDo) {
                // only advance time, do not accumulate any cpuTime
                weHaveTime = this.vm.advanceTo(this.reflectorTime, deadline);
            } else {
                // perform simulation accumulating cpuTime
                const simStart = Stats.begin("simulate");
                // simulate all received external messages
                while (weHaveTime) {
                    const msgData = this.networkQueue[0];
                    if (!msgData) break;
                    // finish simulating internal messages up to message time
                    // (otherwise, external messages could end up in the future queue,
                    // making snapshots non-deterministic)
                    weHaveTime = this.vm.advanceTo(msgData[0], deadline);
                    if (!weHaveTime) break;
                    // Remove message from the network queue
                    this.networkQueue.shift();
                    // have the vm decode and schedule that message
                    // it will end up first in the future message queue
                    const msg = this.vm.scheduleExternalMessage(msgData);
                    // simulate that message
                    weHaveTime = this.vm.advanceTo(msg.time, deadline);
                    // boost cpuTime by a fixed cost per message, to impose an upper limit on
                    // the number of messages we'll accumulate before taking a snapshot
                    this.cpuTime += EXTERNAL_MESSAGE_CPU_PENALTY;
                }
                // finally, simulate up to last tick (whether received or generated)
                if (weHaveTime) weHaveTime = this.vm.advanceTo(this.reflectorTime, deadline);
                this.cpuTime += Math.max(0.01, Stats.end("simulate") - simStart); // ensure that we move forward even on a browser that rounds performance.now() to 1ms
            }
            Stats.backlog(this.backlog);
            // synced is set to null in controller.reset, and is first set to false when
            // this.reflectorTime is given its first meaningful value from a message or
            // tick, or in SYNC.
            // thereafter, synced will only be changed in either direction if there is
            // currently a root view (which is set up and taken down in rebootModelView).
            const lag = this.lag;
            const syncedMin = Math.max(SYNCED_MIN, this.msPerTick * SYNCED_MIN_FACTOR);
            const syncedMax = Math.max(SYNCED_MAX, this.msPerTick * SYNCED_MAX_FACTOR);
            if (typeof this.synced === "boolean" && this.viewed && (this.synced && lag > syncedMax || !this.synced && lag < syncedMin)) {
                const nowSynced = !this.synced;
                // nov 2019: impose a delay before setting synced to true, to hold off processing that depends on being synced (notably, subscriptions with handling "oncePerFrameWhileSynced") long enough to incorporate processing of messages that rightfully belong with the sync batch - e.g., "users" messages after SYNC from reflector.  SYNCED_ANNOUNCE_DELAY is therefore chosen with reference to the reflector's USERS_INTERVAL used for batching the "users" messages.
                if (nowSynced) {
                    // this will be triggered every cycle until synced is eventually set to true.  capture with one timeout.
                    if (!this.syncTimer) {
                        // if we're backgrounded and timers are firing only once per minute,
                        // the sync announcement will probably be delayed.  for now we assume
                        // that that doesn't matter.
                        this.syncTimer = setTimeout(() => {
                            delete this.syncTimer;
                            if (this.connected && this.lag < syncedMin) this.applySyncChange(true); // iff we haven't somehow dropped out of sync again
                            }, SYNCED_ANNOUNCE_DELAY);
                    }
                } else this.applySyncChange(false); // switch to out-of-sync is acted on immediately
            }
            if (this.synced && weHaveTime && this.cpuTime > SNAPSHOT_EVERY) { // important not to schedule (resetting cpuTime) if not synced
                // the triggeringCpuTime will be used whether or not this client
                // ends up being the one that triggers the snapshot.
                this.triggeringCpuTime = this.cpuTime;
                this.cpuTime = 0;
                // first level of defence against clients simultaneously deciding
                // that it's time to take a snapshot: stagger pollForSnapshot sends,
                // so we might have heard from someone else before we send.
                // however, if we're backgrounded so that timers might be firing only once
                // per minute, it would be wrong to wait.
                if (this.isBeingAnimated()) {
                    setTimeout(() => this.scheduleSnapshot(), Math.floor(Math.random()*2000));
                } else this.scheduleSnapshot();
            }
            return weHaveTime;
        } catch (error) {
            displayAppError("simulate", error);
            this.connection.closeConnectionWithError("simulate", error);
            return "error";
        }
    }

    // this is invoked by session.step() - which is called from the default
    // onAnimationFrame handler below, or by the application if it chooses
    // to step manually
    stepSession(stepType, parameters={}) {
        // iff globalThis.logMessageStats is truthy, the Stats object will be gathering
        // per-second message stats and will return a tally once per second.
        const report = Stats.stepSession(parameters.frameTime, true);
        if (report) console.log(report);

        const { backlog, latency, starvation, activity } = this;
        if (stepType === "animation") {
            Stats.animationFrame(parameters.frameTime, { backlog, starvation, latency, activity, users: this.users });

            const now = Date.now();
            if (this.lastAnimationEnd) {
                const thisGap = now - this.lastAnimationEnd;
                // if regular animation had been detected, but this latest gap is
                // unusually long, immediately drop the isBeingAnimated status and
                // start counting frames again.
                if (this.animationGapCheck === true && thisGap > ANIMATION_EXCESSIVE_FRAME_GAP) {
                    this.animationGapCheck = [];
                    if (DEBUG.session) console.log(`${this.id} animation has stopped (too long between steps)`);
                }
                if (this.animationGapCheck !== true) {
                    const gaps = this.animationGapCheck;
                    gaps.push(thisGap);
                    if (gaps.length > ANIMATION_CHECK_FRAMES) gaps.shift();
                    if (gaps.length === ANIMATION_CHECK_FRAMES && gaps.reduce((a, b) => a + b, 0) <= ANIMATION_CHECK_FRAMES * ANIMATION_REASONABLE_FRAME_GAP) {
                        this.animationGapCheck = true;
                        if (DEBUG.session) console.log(`${this.id} animation has started`);
                    }
                }
            }

            this.lastAnimationEnd = now; // will be replaced if we run through to the end
        }

        if (!this.connected) {
            if (!this.isInBackground()) this.checkForConnection(true); // reconnect if not blocked
            return;
        }

        if (!this.vm) return;

        let caughtUp;
        switch (stepType) {
            case "animation": {
                // when average load is low, the balancer spreads simulation across frames by
                // simulating with a budget equal to the mean of the durations recorded from the
                // last LOAD_BALANCE_FRAMES simulations.
                // a session also has a value expectedSimFPS, from which we derive the maximum time
                // slice that the simulation can use on each frame while still letting the app
                // render on time.  whenever the controller is found to have a backlog greater than
                // LOAD_BALANCE_FRAMES times that per-frame slice, the balancer immediately
                // schedules a simulation boost with a budget of MAX_SIMULATION_MS.
                // expectedSimFPS can be set using session param expectedSimFPS; the higher
                // the value, the less of a backlog is needed to trigger a simulation boost.  but
                // if expectedSimFPS is set to zero, the balancer will attempt to clear any backlog
                // on every frame.
                // expectedSimFPS was introduced for our Unity experiments, and is undocumented.
                // as of july 2021, all apps are running with the default value of 60.
                const expectedSimFPS = parameters.expectedSimFPS;
                const simStart = Date.now();
                const simBudget = simLoad.reduce((a, b) => a + b, 0) / simLoad.length;
                caughtUp = this.simulate(simStart + Math.min(simBudget, MAX_SIMULATION_MS));
                if (caughtUp === false) {
                    // maybe take another bite
                    const allowableLag = expectedSimFPS === 0 ? 0 : LOAD_BALANCE_FRAMES * (1000 / expectedSimFPS);
                    if (this.backlog > allowableLag) caughtUp = this.simulate(simStart + MAX_SIMULATION_MS - simBudget);
                }
                if (caughtUp !== "error") {
                    simLoad.push(Date.now() - simStart);
                    if (simLoad.length > LOAD_BALANCE_FRAMES) simLoad.shift();
                }
                break;
                }
            case "fastForward":
            case "background":
                caughtUp = this.simulate(Date.now() + parameters.budget);
                break;
            default:
                console.warn(stepType);
            }

        if (this.fastForwardHandler) this.fastForwardHandler(caughtUp);
        if (caughtUp === "error") return;

        Stats.begin("update");
        this.processModelViewEvents(stepType === "animation");
        Stats.end("update");

        // the buffer for rate-limited SENDS is serviced by timeouts when
        // the session is being animated, and will ignore additional
        // invocations that don't fit its schedule.
        // checking from here means it will also be called when the session
        // is in the background, when we step on every TICK and RECV from
        // the reflector.
        this.serviceRateLimitBuffer();

        if (stepType !== "animation") return;

        if (parameters.view) {
            Stats.begin("render");
            this.inViewRealm(() => parameters.view.update(parameters.frameTime));
            Stats.end("render");
        }

        this.lastAnimationEnd = Date.now();
    }

    applySyncChange(bool) {
        if (DEBUG.session) console.log(this.id, `synced=${bool}`);
        this.synced = bool;
        App.showSyncWait(!bool); // true if not synced
        this.vm.publishFromView(this.viewId, "synced", bool);
    }

    /** execute something in the view realm */
    inViewRealm(fn) {
        return inViewRealm(this.vm, () => fn(this.vm));
    }

    /** call this from main loop to process queued model=>view events
     * @returns {Number} number of processed events
     */
    processModelViewEvents(isInAnimationStep) {
        if (this.vm) {
            return this.vm.processModelViewEvents(isInAnimationStep);
        }
        return 0;
    }

    /** Got the official time from reflector (on SYNC, TICK or RECV), or local tick multiplier.  src is "reflector" or "controller".  rawTime is reflector performance.now() since the resumption of the session, currently (dec 2021) defined in experimental reflectors on RECV events only, if flag "rawtime" is requested on join(). */
    timeFromReflector(time, src, rawTime) {
        if (time < this.reflectorTime) { if (src !== "controller" || DEBUG.ticks) console.warn(`time is ${this.reflectorTime}, ignoring time ${time} from ${src}`); return; }
        if (typeof this.synced !== "boolean") this.synced = false;
        this.reflectorTime = time;
        this.extrapolatedTimeBase = Date.now() - time;
        if (this.vm) Stats.backlog(this.backlog);
        if (this.tickHook) this.tickHook(time, rawTime);
    }

    /** we received a tick from reflector, generate local ticks */
    multiplyTick(time) {
        if (this.localTicker) globalThis.clearInterval(this.localTicker);
        const ms = this.msPerTick;
        const multiplier = this.tickMultiplier;
        let n = 1;
        this.localTicker = globalThis.setInterval(() => {
            this.timeFromReflector(Math.round(time + n * ms), "controller");
            if (DEBUG.ticks) console.log(this.id, "Controller generate TICK " + this.reflectorTime, n);
            if (++n >= multiplier) { globalThis.clearInterval(this.localTicker); this.localTicker = 0; }
        }, ms);
    }

    startStepping(autoStepFn) {
        // session.js won't invoke this for a Node.js app
        const onAnimationFrame = frameTime => {
            if (this.leaving) return; // stop the loop; it's not coming back

            if (!this.isOutOfSight()) autoStepFn(frameTime);

            window.requestAnimationFrame(onAnimationFrame);
        };
        window.requestAnimationFrame(onAnimationFrame);
    }

    setUpActivityChecks() {
        /** intersection with the browser viewport */
        let isVisibleInViewport = null;
        /** whether to consider this tab visible, based on document.visibilityState and our IntersectionObserver */
        this.isOutOfSight = () => !NODE && (document.visibilityState === "hidden" || !isVisibleInViewport);
        /** whether to consider this tab as being animated regularly.  it takes ANIMATION_EXCESSIVE_FRAME_GAP (200ms) to detect that animation has stopped, and ANIMATION_CHECK_FRAMES rapidly scheduled steps to signal that it has restarted. */
        this.isBeingAnimated = () => {
            const gapsOk = this.animationGapCheck === true;
            const delayOk = Date.now() - this.lastAnimationEnd < ANIMATION_EXCESSIVE_FRAME_GAP;
            if (gapsOk && !delayOk) {
                this.animationGapCheck = []; // start counting again
                if (DEBUG.session) console.log(`${this.id} animation has stopped (too long since last step)`);
            }
            return gapsOk && delayOk;
            };
        /** whether to consider this tab as being in the background. */
        this.isInBackground = () => this.isOutOfSight() || !this.isBeingAnimated();

        if (!NODE) {
            const intersectionChanged = (entries, _observer) => isVisibleInViewport = entries[0].isIntersecting;
            const observer = new IntersectionObserver(intersectionChanged);
            observer.observe(document.body);
        }

        // only set up a dormancy check if needed
        const autoSleep = this.sessionSpec.autoSleep; // seconds, or zero to disable
        let checkForDormancy;
        if (autoSleep) {
            const dormantDelay = 1000 * autoSleep;
            let lastDormancyCheck = 0;
            let outOfSightSince = 0;
            checkForDormancy = () => {
                const now = Date.now();
                if (now - lastDormancyCheck < 980) return; // don't insist on 1000

                lastDormancyCheck = now;
                if (this.isOutOfSight()) {
                    if (!outOfSightSince) outOfSightSince = now;
                    else if (now - outOfSightSince > dormantDelay) {
                        this.dormantDisconnect();
                        outOfSightSince = 0; // to force a new timeout if hidden immediately on reconnection
                    }
                } else outOfSightSince = 0;
                };
        }

        const checkAliveness = () => {
            if (this.leaving) {
                if (alivenessPoll) {
                    // stop the poll tidily, in case this is called multiple
                    // times (via ticks) during the time it takes to leave.
                    clearInterval(alivenessPoll);
                    alivenessPoll = null;
                }
                return;
            }

            if (!this.connected || !this.vm) return;

            if (checkForDormancy) checkForDormancy();

            // if the session is not being animated regularly, the setInterval
            // that normally triggers keepAlive probably isn't being stepped
            // either.  do so from here.
            if (!this.isBeingAnimated()) this.connection.keepAlive(Date.now());
            };

        // this poll is likely to be throttled to to once per minute in Chrome
        // if this tab is backgrounded.  checkAliveness is therefore also sent
        // by simulateIfNeeded if the tab is not being regularly stepped.
        let alivenessPoll = setInterval(checkAliveness, 1000);

        this.simulateIfNeeded = () => {
            // if session is connected but not being stepped by animation
            // frames, use ticks to trigger a liveness check and, if still
            // connected after that, run the simulation.
            if (this.isBeingAnimated()) return; // animation is happening as usual

            checkAliveness();

            if (this.connected) {
                // we set a simulation budget of 90% of the tick gap, capped at
                // MAX_SIMULATION_MS unless this app disables dormancy, in which case
                // we allow even a multi-second budget (if the tick is that slow)
                // so that the simulation has all the resources we can throw at it.
                // that said, an app that needs to do lots of simulation ought not
                // to set a low tick rate.
                let simBudget = this.msPerTick * 0.9;
                if (autoSleep) simBudget = Math.min(simBudget, MAX_SIMULATION_MS);
                const stepType = this.synced ? "background" : "fastForward"; // doesn't currently make any difference
                this.stepSession(stepType, { budget: simBudget });
            }
            };
    }

    toString() { return `Controller[${this.id}]`; }

    [Symbol.toPrimitive]() { return this.toString(); }
}


// Socket Connection

/** send PULSEs using this interval until hearing back from server */
const KEEP_ALIVE_INTERVAL = 100;
/** if we haven't sent anything to the reflector for this long, send a PULSE to reassure it */
const PULSE_TIMEOUT = 25000;
/** if we haven't heard anything from the reflector for this long, try reconnecting */
const REFLECTOR_ALIVE_TIMEOUT = 50000;
/** warn about unsent outgoing bytes after this many ms */
const UNSENT_TIMEOUT = 500;
/** increase reconnect timeout exponentially up to this many ms */
const RECONNECT_DELAY_MAX = 30000;

class Connection {
    constructor(controller) {
        this.controller = controller;
        this.socketLastSent = 0;        // only used for keepAlive check
        this.connectBlocked = false;
        this.connectRestricted = false;
        this.connectHasBeenCalled = false;
        this.reconnectDelay = 0;
        this.missingTickThreshold = Infinity;
    }

    get id() { return this.controller.id; }

    setTick(ms) {
        this.missingTickThreshold = Math.min(ms * 3, 45000); // send PULSE after
    }

    get connected() { return !!(this.socket && this.socket.readyState === WebSocket.OPEN); }

    checkForConnection(force) {
        if (this.socket || this.connectHasBeenCalled) return;

        // there are three levels of rights to (re)connect:
        // 1. fully blocked (e.g., to force a pause in attempted reconnection; only a direct connectToReflector will work)
        // 2. blocked unless requested from a session step (force === true)
        // 3. not blocked: any call has the right to connect (e.g., on first connect to a session)
        if (this.connectBlocked) return;
        if (this.connectRestricted && !force) return;

        this.connectToReflector();
    }

    connectToReflector() {
        if (this.socket || this.connectHasBeenCalled) return;

        this.connectHasBeenCalled = true;
        this.connectBlocked = false;
        this.connectRestricted = false;

        let reflectorBase = REFLECTOR;
        const reflectorParams = {};
        const token = this.controller.sessionSpec.token;
        if (token) reflectorParams.token = token;
        if (urlOptions.reflector) {
            const cloudflareColo = urlOptions.reflector.toUpperCase();
            if (cloudflareColo === "CF" || cloudflareColo.match(/^[A-Z]{3}$/)) {
                reflectorBase = DEBUG.reflector ? DEV_CLOUDFLARE_REFLECTOR : CLOUDFLARE_REFLECTOR;
                if (cloudflareColo.length === 3) reflectorParams.colo = cloudflareColo;
            }
            else if (urlOptions.reflector.match(/^[-a-z0-9]+$/i)) reflectorParams.region = urlOptions.reflector;
            else reflectorBase = urlOptions.reflector;
        }
        if (!reflectorBase.match(/^wss?:/)) throw Error("Cannot interpret reflector address " + reflectorBase);
        if (!reflectorBase.endsWith('/')) reflectorBase += '/';
        const reflectorUrl = new URL(reflectorBase + this.id);
        for (const [k,v] of Object.entries(reflectorParams)) reflectorUrl.searchParams.append(k, v);

        const socket = new WebSocket(reflectorUrl);
        socket.onopen = _event => {
            // under some conditions (e.g., switching a device between networks) a new
            // socket can be opened without the old one receiving a close event
            const oldSocket = this.socket;
            if (oldSocket) {
                oldSocket.onopen = oldSocket.onmessage = oldSocket.onerror = oldSocket.onclose = null;
            }
            this.socket = socket;
            this.connectHasBeenCalled = false; // now that we have the socket
            if (DEBUG.session) console.log(this.id, this.socket.constructor.name, "connected to", this.socket.url);
            this.reconnectDelay = 0;
            Stats.connected(true);
            this.controller.sendJoin();
        };
        socket.onmessage = event => {
            if (socket !== this.socket) return; // in case a socket that we've tried to close can still deliver a message
            this.receive(event.data);
        };
        socket.onerror = _event => {
            // an error anywhere between here and the reflector once the socket
            // connection has opened will also result in socket closure, and
            // can therefore be handled in socket.onclose.  but if the socket was
            // never opened successfully, we need to clear connectHasBeenCalled.
            if (DEBUG.session) console.log(this.id, socket.constructor.name, "connection error");
            this.connectHasBeenCalled = false; // ready to try again
            this.controller.clearSyncReceiptTimeout(); // if any
        };
        socket.onclose = event => {
            // triggered when socket is closed from the far end.  when we close
            // it from here, this handler is first nulled out.
            this.socketClosed(event.code, event.reason);
        };
    }

    socketClosed(code, message) {
        // with the introduction of seamless rejoin, the closure of the connection
        // does not directly cause controller.leave() - dismantling the view, etc.
        // controller.connectionInterrupted() sets an independent timer for invoking
        // leave() iff the connection has not been restored within the rejoinLimit.

        this.controller.clearSyncReceiptTimeout(); // if any

        // event codes 4100 and up mean a disconnection from which the client
        // shouldn't automatically try to reconnect
        // e.g., 4100 is for out-of-date reflector protocol
        // in addition, 1000 means user-triggered Session.leave().  everything stops.
        const autoReconnect = code !== 1000 && code < 4100;
        const dormant = code === 4110;
        // don't display error if going dormant or normal close or reconnecting
        if (!dormant && code !== 1000 && !this.reconnectDelay) {
            // but also wait 500 ms to see if reconnect succeeded
            setTimeout(() => {
                if (this.connected) return; // yay - connected again
                App.showMessage(`Connection closed: ${code} ${message}`, {
                    level: autoReconnect ? "error" : "fatal",
                });
            }, 500);
        }
        if (DEBUG.session) console.log(this.id, `${this.socket ? this.socket.constructor.name + " closed" : "closed before opening,"} with code: ${code} ${message}`);
        Stats.connected(false);
        if (dormant) this.connectRestricted = true; // only reconnect on session step
        else this.connectBlocked = true; // only reconnect using connectToReflector
        this.disconnected();
        if (autoReconnect) {
            // the logic above ensures that autoReconnect is only true in conjunction
            // with connectBlocked=true.  therefore nothing else can cause a reconnection
            // before the connectToReflector scheduled here.
            if (DEBUG.session) console.log(this.id, `reconnecting in ${this.reconnectDelay} ms`);
            this.reconnectTimeout = globalThis.setTimeout(() => {
                delete this.reconnectTimeout;
                this.connectToReflector();
            }, this.reconnectDelay);
            // we start reconnecting immediately once (0ms) and then back off exponentially
            // also randomly to avoid hitting the dispatchers at the same time
            this.reconnectDelay = Math.min(RECONNECT_DELAY_MAX, Math.round((this.reconnectDelay + 100) * (1 + Math.random())));
        }
    }

    // from socketClosed handling, whether triggered by remote or local closure
    disconnected() {
        if (!this.socket) return;

        this.socket = null;
        this.lastReceived = 0;
        this.socketLastSent = 0;
        this.stalledSince = 0;
        this.connectHasBeenCalled = false;
        this.controller.connectionInterrupted();
    }

    send(data) {
        this.socketLastSent = Date.now();
        this.socket.send(data);
    }

    receive(data) {
        this.lastReceived = Date.now();
        const { id, action, args } = JSON.parse(data);
        if (id) {
            try { this.controller.receive(action, args); }
            catch (e) { this.closeConnectionWithError("receive", e); }
        } else switch (action) {
            case 'PONG': {
                if (DEBUG.pong) console.log("PONG after", Date.now() - args, "ms");
                if (this.pongHook) {
                    try { this.pongHook(args); }
                    catch (e) { console.error(e); }
                }
                break;
                }
            default: console.warn("Unknown action", action);
        }
    }

    dormantDisconnect() {
        if (!this.connected) return; // not connected anyway
        if (DEBUG.session) console.log(this.id, "dormant; disconnecting from reflector");
        this.closeConnection(4110, "Going dormant");
    }

    closeConnectionWithError(caller, error, code=4000) {
        console.error(error);
        console.warn("closing socket");
        if (code >= 4100 && code !== 4110) this.controller.leaving = () => {}; // dummy function to cause session to shut down irreversibly unless just going dormant
        this.closeConnection(code, "Error in " + caller);
        // closing with error code < 4100 will try to reconnect
    }

    closeConnection(code, message) {
        // NB: if this.socket is non-null this method synchronously sends disconnect(), which nulls it out
        if (!this.socket) return;

        // it turns out that a socket can get into a state in which sending close()
        // doesn't trigger the onclose handler (even though its readyState is OPEN).
        // therefore when the controller wants to force closure - and perhaps
        // reconnection - we null out the handler before sending close(), and call
        // the onclose handling directly.
        this.socket.onclose = null;
        this.socket.close(code, message); // might work, might not
        this.socketClosed(code, message); // we move on, regardless
    }

    PULSE(now) {
        if (!this.connected) return;
        if (this.socket.bufferedAmount === 0) {
            // only send a pulse if no other outgoing data pending
            this.send(JSON.stringify({ action: 'PULSE' }));
            this.stalledSince = 0;
        } else if (this.stalledSince && now - this.stalledSince > UNSENT_TIMEOUT) {
            // only warn about unsent data after a certain time
            console.log(`${this.id} Reflector connection stalled: ${this.socket.bufferedAmount} bytes unsent for ${now - this.stalledSince} ms`);
        } else this.stalledSince = Date.now();
    }

    keepAlive(now) {
        // invoked either from a setInterval of (for now) 100ms, or on every app TICK if
        // the view is not currently being animated.
        if (this.lastReceived === 0) return; // haven't yet consummated the connection
        // the reflector expects to hear from us at least every 30 seconds
        if (now - this.socketLastSent > PULSE_TIMEOUT) this.PULSE(now);
        // if we haven't heard anything from the reflector in 50s, assume that somehow the
        // connection dropped (even though our end of the socket hasn't registered the break)
        else if (now - this.lastReceived > REFLECTOR_ALIVE_TIMEOUT) this.closeConnectionWithError("connection", Error("Reflector has gone away"));
        // also, if we are expecting steady ticks, PULSE if ticks are missing.  goal is to
        // prevent the connection from going idle, because otherwise some router/computer
        // combinations will start to buffer packets instead of delivering them immediately
        else if (now - this.lastReceived > this.missingTickThreshold) this.PULSE(now);
    }

    PING(args = Date.now()) {
        if (!this.connected) return;
        this.send(JSON.stringify({ action: 'PING', args }));
    }
}

globalThis.setInterval(() => {
    for (const controller of Controllers) {
        if (!controller.connected || !controller.vm) continue;
        controller.connection.keepAlive(Date.now());
    }
}, KEEP_ALIVE_INTERVAL);


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

LOGIC TO DETECT BROKEN CONNECTIONS

REFLECTOR:

    if no JOIN received 7s after client connects to a clientless vm, delete the session

    every 5s, starting 37s after JOIN:
        if quiescence > 60s:
            disconnect client (code 4002, so reconnection is allowed)
        else if quiescence > 35s and not a recent, background-aware client:
            ping client

    on pong from client:
        reset quiescence

    on message from client (including PULSE):
        reset quiescence


CONTROLLER:

    if no SYNC received 5s after sending JOIN, close connection and try again

    every 100ms in an animated tab; on every TICK and RECV if not animated (so at worst, on a 30s-interval TICK):
        if socketLastSent > 25s:
            send PULSE to server (max ~25s + 30s since last send)
        else if lastReceived > 50s:
            assume that server connection is broken, and reconnect
        else if lastReceived > min(3*TICK, 45s):
            send PULSE to server

    on any message from server:
        reset lastReceived

    on any send to server:
        reset socketLastSent

* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
