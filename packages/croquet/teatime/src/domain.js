/* eslint-disable-next-line */
const NODE = _IS_NODE_; // replaced by rollup
if (NODE && !globalThis.crypto) globalThis.crypto = require('crypto'); // eslint-disable-line global-require

const VOTE_SUFFIX = '#__vote'; // internal, for 'vote' handling; never seen by user

/** A domain manages subscriptions */
export class Domain {

    constructor() {
        /** maps topic to subscribers, handling is either "immediate" or "queued" or "oncePerFrame"
         * @type {{"scope:event": {handling: Set<{fn: Function, for}>}}}
         */
        this.subscriptions = {};
        /** queue of view events generated by model in this frame */
        this.queuedEvents = [];
        /** data of oncePerFrame events generated by model in this frame */
        this.perFrameEvents = new Map();
        /** data of oncePerFrameWhileSynced events generated by model in this frame */
        this.perSyncedFrameEvents = new Map();
        /**  */
        this.id = uuidv4();
        this.lastId = 0;
    }

    register(_object) {
        return "V" + ++this.lastId;
    }

    deregister(_object) {
    }

    /** Add a subscription
     *
     * @param {String} scope - a string that publishers and subscribers agree on
     * @param {String} event - a name for the event
     * @param {*} subscriber - the owner of this subscription
     * @param {Function} callback - a function called when event is published in scope
     * @param {"immediate"|"queued"|"oncePerFrame"|"oncePerFrameWhileSynced"|"vote"} handling - when to invoke the handler
     */
    addSubscription(scope, event, subscriber, callback, handling) {
        if (handling === 'vote') {
            this.addSubscription(scope, event + VOTE_SUFFIX, subscriber, callback, 'immediate');
            return;
        }

        const topic = scope + ":" + event;
        const handler = callback;
        handler.for = subscriber;
        let subs = this.subscriptions[topic];
        if (!subs) subs = this.subscriptions[topic] = {
            immediate: new Set(),
            queued: new Set(),
            oncePerFrame: new Set(),
            oncePerFrameWhileSynced: new Set(),
        };
        if (!subs[handling]) throw Error(`Unknown subscribe() option: handling="${handling}"`);
        subs[handling].add(handler);
    }

    /** Remove a subscription
     *
     * @param {String} scope - a string that publishers and subscribers agree on
     * @param {String} event - a name for the event
     * @param {*} subscriber - the owner of this subscription
     */
    removeSubscription(scope, event, subscriber, callback=null) {
        const topic = scope + ":" + event;
        const subs = this.subscriptions[topic];
        if (subs) {
            const remaining = _removeSubscriber(subs, subscriber, callback);
            if (remaining === 0) delete this.subscriptions[topic];
        }

        if (!event.endsWith(VOTE_SUFFIX)) this.removeSubscription(scope, event + VOTE_SUFFIX, subscriber);
    }

    /** Remove all subscriptions
     *
     * @param {*} subscriber
     */
    removeAllSubscriptionsFor(subscriber) {
        const topicPrefix = `${subscriber}:`;
        // TODO: optimize this - reverse lookup table?
        for (const [topic, subs] of Object.entries(this.subscriptions)) {
            if (topic.startsWith(topicPrefix)) delete this.subscriptions[topic];
            else {
                const remaining = _removeSubscriber(subs, subscriber);
                if (remaining === 0) delete this.subscriptions[topic];
            }
        }
    }

    /** An event was published. Invoke its immediate handlers now, and/or queue it
     * for later execution in processFrameEvents()
     */
    handleEvent(topic, data, immediateWrapper=fn=>fn()) {
        // model=>view events are typically queued for later execution from the main loop
        // The subscriber is encouraged to request batch handling, which only invokes the handler
        // for the latest event per render frame (e.g. to batch multiple position updates into one)
        // The subscriber may request immediate handling, but it must not modify model state!
        const topicSubscribers = this.subscriptions[topic];
        if (topicSubscribers) {
            if (topicSubscribers.queued.size > 0) this.queuedEvents.push({topic, data});
            if (topicSubscribers.oncePerFrame.size > 0) this.perFrameEvents.set(topic, data);
            if (topicSubscribers.oncePerFrameWhileSynced.size > 0) this.perSyncedFrameEvents.set(topic, data);
            if (topicSubscribers.immediate.size > 0) immediateWrapper(() => {
                for (const handler of topicSubscribers.immediate) {
                    try { handler(data); }
                    catch (err) {
                        console.error(err);
                        console.warn(`Croquet: error "${err.message}" in "immediate" subscription ${topic}`);
                    }
                }
            });
        }
    }

    /** Process all queued and oncePerFrame events that were generated since the last invocation
     * @returns {Number} number of processed events
     */
    processFrameEvents(controllerIsInAnimationStep, controllerIsSynced) {
        let n = 0;

        const processSubs = (topic, data, accessor) => {
            const subscriptions = this.subscriptions[topic];
            if (subscriptions) {
                for (const handler of subscriptions[accessor]) {
                    try { handler(data); }
                    catch (err) {
                        console.error(err);
                        console.warn(`Croquet: error "${err.message}" in "${accessor}" subscription ${topic}`);
                    }
                    n++;
                }
            }
        };

        // process queued events in order (for...of will include any added during the iteration)
        for (const {topic, data} of this.queuedEvents) processSubs(topic, data, 'queued');
        this.queuedEvents.length = 0;

        // only process per-frame events if this has been triggered by an animation step
        if (controllerIsInAnimationStep) {
            // process oncePerFrame events in any order
            for (const [topic, data] of this.perFrameEvents) processSubs(topic, data, 'oncePerFrame');
            this.perFrameEvents.clear();

            // process oncePerFrameWhileSynced events in any order
            if (controllerIsSynced) {
                for (const [topic, data] of this.perSyncedFrameEvents) processSubs(topic, data, 'oncePerFrameWhileSynced');
                this.perSyncedFrameEvents.clear();
            }

            // finally, process any newly queued events
            for (const {topic, data} of this.queuedEvents) processSubs(topic, data, 'queued');
            this.queuedEvents.length = 0;
        }

        return n;
    }

}


function _removeSubscriber(subscriptions, subscriber, callback=null) {
    function removeHandler(handlers) {
        for (const handler of handlers) {
            if ((callback !== null && handler.unbound === callback) || (callback === null && handler.for === subscriber)) {
                handlers.delete(handler);
            }
        }
    }
    removeHandler(subscriptions.immediate);
    removeHandler(subscriptions.oncePerFrame);
    removeHandler(subscriptions.oncePerFrameWhileSynced);
    removeHandler(subscriptions.queued);
    return subscriptions.immediate.size + subscriptions.queued.size + subscriptions.oncePerFrame.size + subscriptions.oncePerFrameWhileSynced.size;
}

export const viewDomain = new Domain();

function uuidv4() {
    const getByte = NODE ? () => crypto.randomBytes(1)[0] : () => crypto.getRandomValues(new Uint8Array(1))[0];
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => {
        return (c ^ getByte() & 15 >> c / 4).toString(16);
    });
}
