const VOTE_SUFFIX = '#__vote'; // internal, for 'vote' handling; never seen by user

/** A domain manages subscriptions */
export class Domain {

    constructor() {
        /** maps topic to handlers, handling is either "immediate" or "queued" or "oncePerFrame" or "oncePerFrameWhileSynced"
         * @type {{["scope:event"]: {[handling]: Set<{fn: Function, for}>}}}
         */
        this.subscriptions = {};
        /** maps subscriber to subscriptions */
        this.subscribers = new Map();
        /** queue of view events generated by model in this frame */
        this.queuedEvents = [];
        /** data of oncePerFrame events generated by model in this frame */
        this.perFrameEvents = new Map();
        /** data of oncePerFrameWhileSynced events generated by model in this frame */
        this.perSyncedFrameEvents = new Map();
        /** counter for subscriberIds */
        this.subscriberIds = 0;
    }

    register(_subscriber) {
        return "V" + ++this.subscriberIds;
    }

    deregister(_subscriber) {
        // assumes subscriptions have been removed before deregistering
    }

    /** Add a subscription
     *
     * @param {String} scope - a string that publishers and subscribers agree on
     * @param {String} event - a name for the event
     * @param {String} subscriberId - the owner of this subscription
     * @param {Function} callback - a function called when event is published in scope
     * @param {"immediate"|"queued"|"oncePerFrame"|"oncePerFrameWhileSynced"|"vote"} handling - when to invoke the handler
     */
    addSubscription(scope, event, subscriberId, callback, handling) {
        if (handling === 'vote') {
            this.addSubscription(scope, event + VOTE_SUFFIX, subscriberId, callback, 'immediate');
            return;
        }

        const topic = scope + ":" + event;
        const handler = callback;
        handler.for = subscriberId;
        let handlers = this.subscriptions[topic];
        if (!handlers) handlers = this.subscriptions[topic] = {
            immediate: new Set(),
            queued: new Set(),
            oncePerFrame: new Set(),
            oncePerFrameWhileSynced: new Set(),
        };
        if (!handlers[handling]) throw Error(`Unknown subscribe() option: handling="${handling}"`);
        handlers[handling].add(handler);
    }

    /** Remove a subscription
     *
     * @param {String} scope - a string that publishers and subscribers agree on
     * @param {String} event - a name for the event
     * @param {String} subscriberId - the owner of this subscription
     */
    removeSubscription(scope, event, subscriberId, callback=null) {
        const topic = scope + ":" + event;
        const handlers = this.subscriptions[topic];
        if (handlers) {
            const remaining = removeSubscriber(handlers, subscriberId, callback);
            if (remaining === 0) delete this.subscriptions[topic];
        }

        if (!event.endsWith(VOTE_SUFFIX)) this.removeSubscription(scope, event + VOTE_SUFFIX, subscriberId);
    }

    /** Remove all subscriptions
     *
     * @param {String} subscriberId
     */
    removeAllSubscriptionsFor(subscriberId) {
        const topicPrefix = `${subscriberId}:`;
        // TODO: optimize this - reverse lookup table?
        for (const [topic, handlers] of Object.entries(this.subscriptions)) {
            if (topic.startsWith(topicPrefix)) delete this.subscriptions[topic];
            else {
                const remaining = removeSubscriber(handlers, subscriberId);
                if (remaining === 0) delete this.subscriptions[topic];
            }
        }
    }

    /** An event was published. Invoke its immediate handlers now, and/or queue it
     * for later execution in processFrameEvents()
     */
    handleEvent(topic, data, immediateWrapper=fn=>fn()) {
        // model=>view events are typically queued for later execution from the main loop
        // The subscriber is encouraged to request batch handling, which only invokes the handler
        // for the latest event per render frame (e.g. to batch multiple position updates into one)
        // The subscriber may request immediate handling, but it must not modify model state!
        const handlers = this.subscriptions[topic];
        if (handlers) {
            if (handlers.queued.size > 0) this.queuedEvents.push({topic, data});
            if (handlers.oncePerFrame.size > 0) this.perFrameEvents.set(topic, data);
            if (handlers.oncePerFrameWhileSynced.size > 0) this.perSyncedFrameEvents.set(topic, data);
            if (handlers.immediate.size > 0) immediateWrapper(() => {
                for (const handler of handlers.immediate) {
                    try { handler(data); }
                    catch (err) {
                        console.error(err);
                        console.warn(`Croquet: error "${err.message}" in "immediate" subscription ${topic}`);
                    }
                }
            });
        }
    }

    /** Process all queued and oncePerFrame events that were generated since the last invocation
     * @returns {Number} number of processed events
     */
    processFrameEvents(controllerIsInAnimationStep, controllerIsSynced) {
        let n = 0;

        const invokeHandlers = (handling, topic, data) => {
            const handlers = this.subscriptions[topic];
            if (handlers) {
                for (const handler of handlers[handling]) {
                    try { handler(data); }
                    catch (err) {
                        console.error(err);
                        console.warn(`Croquet: error "${err.message}" in "${handling}" subscription ${topic}`);
                    }
                    n++;
                }
            }
        };

        // process queued events in order (for...of will include any added during the iteration)
        for (const {topic, data} of this.queuedEvents) invokeHandlers('queued', topic, data);
        this.queuedEvents.length = 0;

        // only process per-frame events if this has been triggered by an animation step
        if (controllerIsInAnimationStep) {
            // process oncePerFrame events in any order
            for (const [topic, data] of this.perFrameEvents) invokeHandlers('oncePerFrame', topic, data);
            this.perFrameEvents.clear();

            // process oncePerFrameWhileSynced events in any order
            if (controllerIsSynced) {
                for (const [topic, data] of this.perSyncedFrameEvents) invokeHandlers('oncePerFrameWhileSynced', topic, data);
                this.perSyncedFrameEvents.clear();
            }

            // finally, process any newly queued events
            for (const {topic, data} of this.queuedEvents) invokeHandlers('queued', topic, data);
            this.queuedEvents.length = 0;
        }

        return n;
    }

}


function removeSubscriber(handlers, subscriberId, callback=null) {
    let remaining = 0;
    for (const handling of ['immediate', 'queued', 'oncePerFrame', 'oncePerFrameWhileSynced']) {
        for (const handler of handlers[handling]) {
            if (handler.for === subscriberId && (callback === null || handler.unbound === callback)) {
                handlers[handling].delete(handler);
            }
        }
        remaining += handlers[handling].size;
    }
    return remaining;
}

export const viewDomain = new Domain();
