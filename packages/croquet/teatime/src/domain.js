const VOTE_SUFFIX = '#__vote'; // internal, for 'vote' handling; never seen by user

/** A domain manages subscriptions */
export class Domain {

    constructor() {
        /** maps topic to handlers, handling is either "immediate" or "queued" or "oncePerFrame" or "oncePerFrameWhileSynced"
         * @type {{[topic: String]: {[handling: String]: Set<{fn: Function, for: String}>}}}
         */
        this.subscriptions = {};
        /** maps subscriber to subscribed topics
         * @type {Map<String, Set<String>>}
        */
        this.subscribers = new Map();
        /** true if we have any generic subscriptions, with "*" as scope or event */
        this.genericSubscriptions = false;
        /** queue of view events generated by model in this frame */
        this.queuedEvents = [];
        /** data of oncePerFrame events generated by model in this frame */
        this.perFrameEvents = new Map();
        /** data of oncePerFrameWhileSynced events generated by model in this frame */
        this.perSyncedFrameEvents = new Map();
        /** counter for subscriberIds */
        this.subscriberIds = 0;
        /** meta data for event currently being handled */
        this.currentEvent = undefined;
        /** @type {boolean} true if the currentEvent was published by a model */
        this.currentEventFromModel = false;
    }

    register(_subscriber) {
        return "V" + ++this.subscriberIds;
    }

    deregister(_subscriber) {
        // assumes subscriptions have been removed before deregistering
    }

    /** Add a subscription
     *
     * @param {String} scope - a string that publishers and subscribers agree on
     * @param {String} event - a name for the event
     * @param {String} subscriberId - the owner of this subscription
     * @param {Function} callback - a function called when event is published in scope
     * @param {"immediate"|"queued"|"oncePerFrame"|"oncePerFrameWhileSynced"|"vote"} handling - when to invoke the handler
     */
    addSubscription(scope, event, subscriberId, callback, handling) {
        if (scope.includes(':')) throw Error(`Invalid subscription scope "${scope}" (must not contain ':')`);

        if (handling === 'vote') {
            this.addSubscription(scope, event + VOTE_SUFFIX, subscriberId, callback, 'immediate');
            return;
        }

        if (scope === "*" || event === "*") this.genericSubscriptions = true;

        const topic = scope + ":" + event;
        const handler = callback;
        handler.for = subscriberId;
        let handlers = this.subscriptions[topic];
        if (!handlers) handlers = this.subscriptions[topic] = {
            immediate: new Set(),
            queued: new Set(),
            oncePerFrame: new Set(),
            oncePerFrameWhileSynced: new Set(),
        };
        if (!handlers[handling]) throw Error(`Unknown subscribe() option: handling="${handling}"`);
        handlers[handling].add(handler);
        let topics = this.subscribers.get(subscriberId);
        if (!topics) this.subscribers.set(subscriberId, topics = new Set());
        topics.add(topic);
    }

    /** Remove a subscription
     *
     * @param {String} scope - a string that publishers and subscribers agree on
     * @param {String} event - a name for the event
     * @param {String} subscriberId - the owner of this subscription
     * @param {Function} callback - the callback function to remove, or null to remove all callbacks for this topic
     */
    removeSubscription(scope, event, subscriberId, callback=null) {
        const topic = scope + ":" + event;
        const handlers = this.subscriptions[topic];
        if (handlers) {
            const remaining = removeHandlers(handlers, subscriberId, callback);
            if (remaining === "none") delete this.subscriptions[topic];
            if (remaining !== "subscriber") {
                const topics = this.subscribers.get(subscriberId);
                topics.delete(topic);
                if (topics.size === 0) this.subscribers.delete(subscriberId);
            }
        }
        if (!event.endsWith(VOTE_SUFFIX)) this.removeSubscription(scope, event + VOTE_SUFFIX, subscriberId);
    }

    /** Remove all subscriptions
     *
     * @param {String} subscriberId
     */
    removeAllSubscriptionsFor(subscriberId) {
        const topics = this.subscribers.get(subscriberId);
        if (topics) {
            for (const topic of topics) {
                const handlers = this.subscriptions[topic];
                if (handlers) {
                    const remaining = removeHandlers(handlers, subscriberId);
                    if (remaining === "none") delete this.subscriptions[topic];
                } else {
                    console.error(`Croquet: topic ${topic} not found in subscriptions table for ${subscriberId} during removeAllSubscriptionsFor()`);
                }
            }
            this.subscribers.delete(subscriberId);
        }
    }

    subscriptionsFor(topic) {
        const subscription = this.subscriptions[topic];
        if (!subscription && !this.genericSubscriptions) return null; // quick exit if no subscribers
        const subscriptions = [];
        let hasUserSubcription = !!subscription;
        // if we have generic subscriptions, add them before the specific one
        if (this.genericSubscriptions) {
            const [ scope, event ] = topic.split(':');
            if (!((scope.startsWith("__") && scope.endsWith("__"))
                || (event.startsWith("__") && event.endsWith("__")))) {
                // order from most generic to most specific
                for (const generic of ["*:*", scope + ":*", "*:" + event]) {
                    const genericSubscription = this.subscriptions[generic];
                    if (genericSubscription) {
                        subscriptions.push([genericSubscription, generic]);
                        if (!hasUserSubcription && this.hasUserSubcription(genericSubscription)) {
                            hasUserSubcription = true;
                        }
                    }
                }
            }
            const onlyGeneric = !hasUserSubcription;
            if (onlyGeneric) for (const genericSubscription of subscriptions) {
                genericSubscription.push(onlyGeneric);
            }
        }
        if (subscription) subscriptions.push([subscription, topic]);
        if (subscriptions.length === 0) return null;
        return subscriptions;
    }

    hasUserSubcription(subscription) {
        for (const handling of ['immediate', 'queued', 'oncePerFrame', 'oncePerFrameWhileSynced']) {
            for (const handler of subscription[handling]) {
                if (!handler.unbound.__CROQUET__) {
                    return true;
                }
            }
        }
        return false;
    }

    /** An event was published. Invoke its immediate handlers now, and/or queue it
     * for later execution in processFrameEvents()
     */
    handleEvent(topic, data, immediateWrapper=null) {
        // model=>view events are typically queued for later execution from the main loop
        // The subscriber is encouraged to request batch handling, which only invokes the handler
        // for the latest event per render frame (e.g. to batch multiple position updates into one)
        // The subscriber may request immediate handling, but it must not modify model state!
        const subscriptions = this.subscriptionsFor(topic);
        if (!subscriptions) return; // quick exit if no subscribers
        const fromModel = !!immediateWrapper;
        let queued = 0;
        let oncePerFrame = 0;
        let oncePerFrameWhileSynced = 0;
        for (const [handlers, currentEvent, onlyGeneric] of subscriptions) {
            queued += handlers.queued.size;
            oncePerFrame += handlers.oncePerFrame.size;
            oncePerFrameWhileSynced += handlers.oncePerFrameWhileSynced.size;
            if (handlers.immediate.size > 0) {
                if (!immediateWrapper) immediateWrapper = fn => fn();
                immediateWrapper(() => {
                    for (const handler of handlers.immediate) {
                        const prevEvent = this.currentEvent;
                        const prevEventFromModel = this.currentEventFromModel;
                        const prevEventOnlyGeneric = this.currentEventOnlyGeneric;
                        this.currentEvent = topic;
                        this.currentEventFromModel = fromModel;
                        this.currentEventOnlyGeneric = onlyGeneric;
                        try { handler(data); }
                        catch (err) {
                            console.error(err);
                            console.warn(`Croquet: error "${err.message}" in "immediate" subscription ${currentEvent}`);
                        }
                        this.currentEvent = prevEvent;
                        this.currentEventFromModel = prevEventFromModel;
                        this.currentEventOnlyGeneric = prevEventOnlyGeneric;
                    }
               });
            }
        }
        if (queued > 0) this.queuedEvents.push({topic, data, fromModel});
        if (oncePerFrame > 0) this.perFrameEvents.set(topic, {data, fromModel});
        if (oncePerFrameWhileSynced > 0) this.perSyncedFrameEvents.set(topic, {data, fromModel});
    }

    /** Process all queued and oncePerFrame events that were generated since the last invocation
     * @returns {Number} number of processed events
     */
    processFrameEvents(controllerIsInAnimationStep, controllerIsSynced) {
        let n = 0;

        const invokeHandlers = (handling, topic, data, fromModel) => {
            const subscriptions = this.subscriptionsFor(topic);
            if (!subscriptions) return; // quick exit if no subscribers
            const prevEvent = this.currentEvent;
            const prevEventFromModel = this.currentEventFromModel;
            this.currentEvent = topic;
            this.currentEventFromModel = fromModel;
            for (const [handlers, _genericTopic, onlyGeneric] of subscriptions) {
                const prevEventOnlyGeneric = this.currentEventOnlyGeneric;
                this.currentEventOnlyGeneric = onlyGeneric;
                for (const handler of handlers[handling]) {
                    try { handler(data); }
                    catch (err) {
                        console.error(err);
                        console.warn(`Croquet: error "${err.message}" in "${handling}" subscription ${topic}`);
                    }
                    n++;
                }
                this.currentEventOnlyGeneric = prevEventOnlyGeneric;
            }
            this.currentEvent = prevEvent;
            this.currentEventFromModel = prevEventFromModel;
    };

        // process queued events in order (for...of will include any added during the iteration)
        for (const {topic, data, fromModel} of this.queuedEvents) invokeHandlers('queued', topic, data, fromModel);
        this.queuedEvents.length = 0;

        // only process per-frame events if this has been triggered by an animation step
        if (controllerIsInAnimationStep) {
            // process oncePerFrame events in any order
            for (const [topic, {data, fromModel}] of this.perFrameEvents) invokeHandlers('oncePerFrame', topic, data, fromModel);
            this.perFrameEvents.clear();

            // process oncePerFrameWhileSynced events in any order
            if (controllerIsSynced) {
                for (const [topic, {data, fromModel}] of this.perSyncedFrameEvents) invokeHandlers('oncePerFrameWhileSynced', topic, data, fromModel);
                this.perSyncedFrameEvents.clear();
            }

            // finally, process any newly queued events
            for (const {topic, data, fromModel} of this.queuedEvents) invokeHandlers('queued', topic, data, fromModel);
            this.queuedEvents.length = 0;
        }

        return n;
    }

}

// remove handlers from a topic
function removeHandlers(handlers, subscriberId, callback=null) {
    let remaining = "none";
    for (const handling of ['immediate', 'queued', 'oncePerFrame', 'oncePerFrameWhileSynced']) {
        for (const handler of handlers[handling]) {
            if (handler.for !== subscriberId) {
                if (remaining === "none") remaining = "others"; // there are other subscribers for the same topic
                continue;
            }
            if (callback === null || handler.unbound === callback) {
                handlers[handling].delete(handler);
            } else {
                remaining = "subscriber"; // even this subscriber has other handlers for the same topic
            }
        }
    }
    return remaining;
}

export const viewDomain = globalThis.CROQUETVD = new Domain();
